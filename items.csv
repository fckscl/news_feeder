link,next,text,title
[<200 https://habr.com/ru/post/662770/>],page2,"Нейронные сети используются для множества задач, но слышали ли вы когда-нибудь про распознавание птиц? Мы – нет, поэтому возможность поработать над этим проектом очень нас захватила, а опыт по итогу оказался крайне интересным.,Птицы миллионы лет эволюционировали в сторону незаметности и слияния с окружающей средой, чтобы избежать хищников. Поэтому ученым и любителям птичек достаточно сложно искать птиц среди деревьев и кустарников. Но вот наблюдать за ними с помощью видеокамеры, не выходя из дома, — прекрасный способ, который сильно экономит время. Особенно если искусственный интеллект избавит пользователя от необходимости просматривать часы видеозаписей в поисках птиц, просто отправив уведомление на телефон, когда птица попала в поле зрения камеры. Более того, искусственный интеллект еще и автоматически определит её вид.,Наш клиент предполагает продавать своим потребителям предложение – сервис по распознаванию птиц и камеры, на которые будут фиксироваться птицы.,ИИ для наблюдения за птицами состоит из двух частей:,обнаружение объекта - нейронная сеть, отвечающая за детектирование присутствия птицы или млекопитающего в кадре,классификация объектов - нейронная сеть, отвечающая за определение того, какой вид птицы или млекопитающего был снят,Когда объект обнаружен, система записывает короткое видео, к которому затем пользователь получает доступ, и делает нескоько снимков для отправки на сервер, где модель классификации определяет, какой тип птицы или животного попал в камеру.,Сегодня мы расскажем вам про первую нейронную сеть, отвечающую за обнаружение птиц в объективе камеры.,Чтобы сделать свой продукт доступным по цене, клиент провел маркетинговое исследование и выяснил цену, по которой клиенты готовы покупать камеры и сервис.,Единственное, на чем клиенту удалось сэкономить – камеры. Здесь мы столкнулись с проблемой оборудования. Клиент закупил дешевые китайские камеры.,Работа с дешевой камерой означает работу с дешевым чипсетом, что делает невозможным использование архитектуры нейронной сети по умолчанию. По сравнению с первоклассным золотым стандартом видеокамер компьютерного зрения — NVIDIA Jetson Nano, которая позволяет использовать около 120 слоев YOLO v4 по умолчанию, камеры, с которыми нам пришлось работать, допускали только 22 слоя.,То есть модель урезана в несколько раз. Там, где полноценная нейронная сеть YOLO v4 обеспечивает отличные результаты распознавания, “урезанная” версия работает плохо. На момент старта работ, YOLO v4 была самой актуальной версией.,Мы протестировали оба варианта и были неприятно удивлены тем, насколько низкой оказалась обобщающая способность модели (способность запоминать свойства объектов) при запуске на дешевом чипсете.,Мы начали с обучения дефолтной модели YOLO v4 и её тестирования на датасете заказчика. Достигнутые нами результаты оказались удовлетворительными — 95% mAp, чего в мире компьютерного зрения более чем достаточно для запуска в продакшн.,После адаптации модели под параметры китайской камеры, качество обнаружения сильно упало.,Далее мы протестировали нейронную сеть на тестовых данных и получили метрики с тестового набора данных, а также визуально отсмотрели результаты. Это дало понимание, где сети не хватало знаний и где она делала больше всего ошибок.,Сеть стремилась распознать людей, особенно руки людей, как животных. Поэтому нам пришлось поработать над тем, чтобы научить сеть игнорировать людей и вместо этого сосредоточиться на птицах и млекопитающих.,Для того, чтобы сеть перестала определять людей и животных как птиц, мы добавили негативные примеры: изображения людей в разных ракурсах, а также человеческие руки, 12 типов лесных млекопитающих, таких как белки, хорьки, опоссумы, еноты и барсуки.,Нам пришлось визуализировать данные на тестовых данных, т.е. понять, какие данные сеть не видит. Мы написали скрипт, который оценил расхождения с разметкой нового датасета. 10 000 изображений мы просматривали вручную. Например, в одном случае рядом с кормушкой была фигурка жабы, и нейронка определяла жабу как птицу.,Камеры имеют два режима – обычный дневной режим, при котором получаются полноцветные изображения, и ночной инфракрасный режим, при котором получаются черно-белые изображения.,Когда камера переключилась на инфракрасный режим, модель выдала очень много ложных срабатываний: листья деревьев шевелятся на ветру,различные насекомые и мотыльки, которых привлекает теплая яркая камера, садовые фонтаны итд.,Чтобы камера меньше просыпалась ночью и записывала ненужные предметы, мы собрали случаи ложных срабатываний в ночных условиях и разметили их вручную.,В датасете клиента было много данных с гугл фотографий и ютуба. Это были четкие красивые фотографии. Но используемые китайские камеры не выдавали картинок такого качества, к тому же жизнь на картинках отличается от реальности: птицы часто сидят спиной или боком к камере, камера может быть в каплях воды, пыли, грязи.,На решение этой проблемы потребовалось время. Заказчик собирал живые данные со своих камер. Сотрудники клиента, в том числе и орнитологи, сидели, отсматривали и выбирали “живые” изображения птиц с камер, чтобы дообучить нашу модель.,Подытожим, что было проделано:,мы тщательно изучали и отрабатывали те случаи, когда сеть неправильно отрабатывала,научили сеть игнорировать людей и не определять их как птиц или млекопитающих,поработали с черно-белыми изображениями и ложными срабатываниями в ночное время,дополнили датасет изображениями птиц в реальных условиях, под разными углами и в разных погодных условиях,После выполнения всего вышеперечисленного, нам удалось добиться 0,975 mAP для обнаружения объектов. Это очень хороший результат для модели компьютерного зрения, поскольку все стремятся к минимуму для любой CV-модели – обнаружение более 0,94 mAP объектов.,Хотя результатов, которых мы достигли сейчас, более чем достаточно для использования в конечном продукте, еще есть возможности для улучшения:,сеть ошибочно принимает цветы за птиц;,птицы не всегда определяются как птицы, если сидят спиной к камере;,птицы не всегда определяются как птицы, если частично чем-то закрыты;,сеть плохо определяет слишком близко находящихся к камере птиц.,После того, как будет собрано достаточно изображений для каждой группы (необходимо более 1000 изображений с камер), мы ожидаем, что mAP достигнет 0,985.,Анализ требований и ознакомление с данными заказчика.,Обучение нейронной сети, отвечающей за детектирование присутствия птицы или млекопитающего в кадре,Доработка датасета заказчика,Тестирование нейронной сети, отвечающей за детектирование присутствия птицы или млекопитающего в кадре,Корректировка нейронной сети, отвечающей за детектирование птиц,Обучение нейронной сети, отвечающей за классификацию птиц или млекопитающих,Тестирование нейронной сети, отвечающей за классификацию птиц или млекопитающих,Корректировка нейронной сети, отвечающей за классификацию птиц или млекопитающих,Запуск проекта в продакшн: клиент начал продажи камер и сервиса,Доработки и корректировки нейронной сети, отвечающей за классификацию птиц или млекопитающих,Поддержка проекта,На момент написания статьи проект прошел стадию №5 - корректировка нейронной сети, отвечающей за детектирование птиц.,Darknet yolo v.4, caffe,2 ai-developer,1 project manager,Оставайтесь с нами, мы обязательно расскажем, как мы работали над второй нейросетью, которая отвечает за классификацию снятых камерами объектов. Там еще больше интересного!,Разрабатываем цифровые сервисы для бизнеса",Как мы распознавали птиц при помощи камер и искусственного интеллекта (часть 1) / Хабр
[<200 https://habr.com/ru/post/662676/>],page2,"Серега уезжал покорять Москву, и я зашел к нему попрощаться, пожелать удачи. Взять нужно было все самое необходимое, все для новой работы и все для новой жизни. Кота хотелось бы оставить, но пришлось брать. А вот с другими обитателями квартиры – огромным числом фиалок, нужно было распрощаться. ,— Возьмешь фиалку? Марина выращивает, не везти же их все с собой. Мы их всем друзьям раздаем. ,Я ответил, что не держу дома цветов, поскольку забываю их поливать, и они у меня быстро загибаются. Поэтому у меня только кактус.,— Эту фиалку поливать не нужно. ,Он принес из комнаты цветок, и я был вынужден признать верность его заявления. Фиалка имела «систему автополива». Растение было посажено в маленький горшок, который помещался в большой пластиковый стакан, вроде бы из под кваса. Из горшка спускалась веревочка, через которую и поступала необходимая для жизни влага. Таким образом, залив один раз пол литра, можно было не беспокоиться о цветке несколько месяцев. Фиалку я взял. ,Пожалуй, верёвочная система полива одна из лучших, с которой мне приходилось встречаться. Растение не требует внимания, потребляет ровно необходимое для жизни количество воды, пускает корни вокруг шнура, как следствие цветёт. К сожалению, цветет не только растение, но и вода. А точнее все, что находится вокруг веревки, спускающийся в стакан. Не то, чтобы меня это сильно расстраивало, выглядит все вполне культурно – сверху цветы, снизу водоросли. Разумеется, можно время от времени менять дренаж, тогда вообще не будет нареканий. Но есть другая проблема – почва вокруг горшка сильно высыхает, ведь влага поступает только снизу. Ну и чисто эстетически, растение в глиняном горшке выглядит солиднее, чем растение в пластиковом горшке и уж подавно лучше, чем в горшке и в пластиковом стакане. ,Так что спустя некоторое время купил я почву, глиняный горшок и высадил цветок как положено. За то время, которое фиалка находится у меня, она практически стала членом семьи и уже давно заслужила к себе более бережного обращения. В общем, решил я сделать устройство для автоматического полива. ,Почему сделать, а не купить готовое? Потому, что делаю для себя, интересен процесс, запас STM32F030 ещё не исчерпан. С аналогами познакомился для интереса и ответа на некоторые вопросы.,Какой выбрать конструктив?,Какие у аналогов есть достоинства и недостатки?,Какие у аналогов есть настройки и режимы работы?,и т.д.,Для примера можно взять устройство для автоматического полива Easygrow. Достойное решение, из очевидных преимуществ – крепление на бутылку. Правда, бутылка будет стоять среди цветов. Из недостатков – периодически придется менять батарейки, слабый интерфейс управления. В результате таких исследований и рассуждений появились требования к устройству.,Питание от Li-Ion аккумулятора с зарядом от солнечной батареи, микропотребление;,Индикация уровня воды в баке и уровня заряда АКБ;,Принудительный полив (т.е. при помощи насоса, не самотеком);,Возможность установки интервала полива и объема жидкости;,Наличие звуковой сигнализации (на случай, если закончится вода);,Интуитивно понятный пользовательский интерфейс.,Получаем следующую структурную схему. ,Компоненты выбраны следующие: микроконтроллер STM32, микросхема заряда CN3065, LDO MCP1700-3302E/MB, EEPROM 24LC64-I/SN, датчики уровня воды SS39ET (датчики Холла), дисплей  0.91″ OLED (128x32, SSD1306), насос погружной  JT-DC3W-3, солнечная батарея с выходным напряжением до 6 В. Насос коммутируется через полевой транзистор, питание датчиков осуществляется с микроконтроллера (для возможности отключения питания). В процессе отладки программы добавил на схему еще транзистор для отключения питания дисплея и памяти. Они хотя и потребляют в режиме сна десяток микроампер, но и используются очень редко. ,Раз обмолвился о потреблении, то с него и начну. Получилось достойно. В режиме сна 25 мкА, в активном режиме 10 мА (с автоматическим уходом в сон), в режиме полива до 200 мА. Если на солнечной батарее держится 3…4 вольта, CN3065 не будет спасть, потребление возрастет до 300 мкА. Расчеты подсказывают, что с таким токопотреблением аккумулятора должно хватить минимум на полгода (при умеренном поливе). Благодаря зарядке от солнечной батареи проблем вообще быть не должно. Однако на этапе проектирования на всякий случай был добавлен разъем MiniUSB, мало ли чего. В слабо освещенной комнате солнечная батарея бесполезна. ,Забавная история вышла с поплавком, он не всплывал. Поплавок состоит из пластиковой части с «замурованным» магнитом. Очевидно, что суммарная плотность поплавка должна быть меньше плотности воды, чего удалось добиться через несколько итераций. Однако, если поплавок опустить в стакан с водой, то он ориентируется по линиям магнитного поля Земли. Находясь внутри бачка, поплавок пытается развернуться и упирается в направляющие корпуса. Тем самым создается дополнительное трение. Учитывая, что баланс плотностей был «на грани», этого самого трения хватало для того, чтобы поплавок оставался под водой. ,С корпусом тоже были проблемы. От него осталось мокрое место, в буквальном смысле слова. Технология печати не была выдержана, в нескольких местах пластик подтекал. Проблему пришлось решать при помощи герметика-аэрозоля KUDO KUH301. ,Относится устройство к классу культурных. По напряжению солнечной батареи определяется время суток с точностью определения времени – сейчас светло или сейчас темно. Если сейчас темно, полив будет отложен. Аналогично, если в баке закончится вода, то устройство будет каждый час давать звуковой сигнал. Но только в светлое время. ,Время демонстрировать работу. ,Еще пара слов по проекту. Была идея реализовать функцию «интеллектуального полива», опираясь на текущую температуру и текущую влажность. Данные по температуре в устройстве имеются, а вот с влажностью все намного сложнее. Отличный , датчиков влажности сделал Sergey MODE, в котором показал, что получаемые данные не надежны и зависят от большого числа факторов. Достоверно оценить влажность почвы – задача нетривиальная. Также спасибо @riva-lab за , для генерации шрифтов. Шрифт Courier 15 импортирован при помощи данной программы. ,Разумеется, вопросов еще много. Объем полива, например, зависит от уровня воды в баке (необходимо наполнять трубку), а влажность почвы зависит от погоды на улице. Как выбрать подходящий режим? А как правильно  для данного устройства измерять токопотребление. Как среднее значение или как среднее квадратичное? Ведь потребляет устройство импульсами. А хватит ли уровня освещенности для заряда осенью и зимой? Сколько времени проработает дешевый китайский насос? И т. д. ,Недавно ездил в Москву, встретился с Серегой, отведал бурятской кухни. Рассказал про фиалку, которую поливать не нужно. Правда фиалку по-прежнему нужно обрезать, удалять старые листья, крутить на солнце и удобрять. ,Разработка электроники",Фиалку поливать не нужно / Хабр
[<200 https://habr.com/ru/post/662670/>],page2,"Средства межсетевого экранирования стали де-факто атрибутом любой сетевой инфраструктуры. Почтовому трафику тоже необходимы средства фильтрации. Поэтому в современных , реалях тяжело представить почтовую инфраструктуру организации без , (,)., (ЭП) является одним из векторов атак, как средство для доставки ВПО клиентам с целью проникновения в корпоративную сеть организации. Но у ЭП есть и еще один враг - спам, мешающий работе и заполняющий полезное дисковое пространство на почтовых серверах. Для решения данных проблем, уже разработаны решения: коммерческие и распространяемых под свободными лицензиями. Из коммерческих наибольшей популярностью пользуется продукт ,. Но все мы знаем про проблемы ""окирпичичвания"" и , окончания лицензий вендоров в текущих условиях, поэтому попробуем посмотреть в сторону свободно распространяемых продуктов.,Свободные решения считаются более сложными в настройке и требуют опыта настройки и администрирования. Конечно, можно накатить , и поставить туда , с использованием , и ,. Однако, если вам, как и мне, хотелось бы раскатать одну виртуалку (в которой уже из коробки есть все необходимое), зайти на вебку и все там настроить - тогда ваш выбор - ,.,Многие слышали о Proxmox благодаря решению для виртуализации - ,, как замену , от VMWare. Поэтому людям, знакомых с ,, , не покажется чем-то новым в установке и администрировании, так как это тот же Debian с тем же Web-интерфейсом, только заточен под ЭП.,Честно сказать, я думал, что мало кто использует данный программный продукт и скептически относился к нему, как замена для ESA. Однако, информация с , меня удивила и придала мне уверенности, что я не один такой.,Как говорилось выше, почтовый шлюз является аналогией межсетевого экранирования для почты. Поэтому ставить PMG, как и любой другой шлюз, нужно , (на границе попадания почтового трафика извне) ,. Таким образом, между SMTP-сервером отправителя (или спамера) и SMTP-сервером получателя есть барьер в виде почтового шлюза.,PMG поставляется в виде ,инсталлятора. Поэтому на чем его устанавливать - решение на вкус и цвет каждого. Хоть на старый ПК, хоть на сервак, хоть использованием виртуализации.,Установка предельно простая, описана в официальной документации и мало чем отличается от установки типичной ОС из ISO-инсталлятора. Пользователи PVE вообще не заметят существенной разницы.,После успешной установки, для управления PMG необходимо перейти в браузере по адресу: , и ввести учетные данные, указанные при установке.,Если описывать настройку всех возможностей, то статья превратится в документацию сайта разработчика, поэтому опишу кратко основные (необходимые) параметры., Для настройки (администрирования) механизмов почтового шлюза представлены следующие ,:, - настройка цепочек правил контентной фильтрации писем (аналог , у ESA). Касается обработки писем и действий над ними;, - настройка основных параметров самого шлюза. Включение/отключение механизмов защиты, настройки сети, ретрансляции, антивирусного и спам движков, управление пользователями, настройка кластера, бекапирования, сертификатов;, - управление почтовыми очередями, карантинами, настройка Black/White листов, просмотр трекинга сообщений;,PMG из коробки уже наделен цепочками правил в ,, готовыми к работе на страже вашего почтового трафика. Подробно останавливаться на этом не вижу смысла, кто работал с ESA - поймет, и допилит под себя, кто впервые на это смотрит - необходимо понять суть. Суть в том, что для построений цепочек правил (,) существуют следующие объекты:, - действия, применяемые при попадании в правило (Rule). Например, доставить письмо пользователю, дропнуть письмо, поместить в карантин, удалить вложения, оповестить администратора и т.д.;, - сгруппированные по какому-либо признаку списки объектов, относящихся к отправителю или получателю (конкретные адреса, домены, IP-адреса, регулярные выражения и т.д.);, - сгруппированные по какому-либо признаку списки объектов, относящихся к содержимому электронного письма (картинки, ссылки, вложения, офисные файлы и т.д.);, - сгруппированные по какому-либо признаку списки объектов, относящихся к временному интервалу, например, нерабочее время или ночь;,Соответственно, подобно составлению ACL, комбинирование данных объектов в цепочку - это и есть правила. Образно работает это так:, Если мне прислали письмо от , (адрес из Blacklist в ,), в письме офисный документ .docx (файл из ,) - заблокировать письмо или отправить в карантин (действие из ,).,Основной раздел для настройки работы почтового шлюза. В этом разделе первым делом нужно настроить ,.,В разделе , в поле , указываем IP-адрес или доменное имя SMTP-сервера, на который нужно отправлять письма дальше (сервер, обслуживающий ваш домен)., В разделе , необходимо добавить ,, обслуживаемые вашим SMTP-сервером. Делается это для того, чтобы PMG понимал, какие письма ему обрабатывать и отправлять дальше., В разделе , вы можете изменить какие порты PMG должен слушать. По-умолчанию 25 порт (,) служит для приема писем снаружи (из Интернета). Порт 26 (,) является релеем для получения писем от вашего почтового сервера и отправки их затем наружу (на другие почтовые домены)., В разделе , необходимо указать какому домену какой SMTP-сервер использовать для пересылки. У вас может быть несколько обслуживаемых доменов и на каждый из этих доменов может быть свой SMTP-сервер., В разделе , необходимо указать , - сети с которых будет , прием для пересылки на другие домены. Делается это для того, чтобы письма пересылались наружу только с ваших доверенных SMTP-серверов., В разделе , можно включить TLS при отправки и получении сообщений. Это означает, что при включенном TLS PMG будет пытаться отправлять письма наружу с использованием расширения ESMTP - ,, а так же сможет такие такие письма принять., В разделе , можно включить подпись исходящих сообщений. О том как добавить в PMG свой ключ подписи - написано в документации., В разделе , можете указать те адреса и домены, которые не будут проходить проверки, включенные в разделе ,., В разделе , настраивайте механизмы проверок в зависимости от политики вашей организации. От себя хочу посоветовать изменять стандартный баннер и не показывать всем, что вы используете.,На этом основное конфигурирование почтового шлюза заканчивается. Все остальные настройки корректируются в зависимости от ваших личных предпочтений и требований безопасности.,В качестве антиспам-решения PMG использует под капотом ,. По-умолчанию включен и готов к работе из коробки. Для изменения параметров антиспама используются разделы:, ,В качестве АВЗ PMG использует движок ,. По-умолчанию включен и готов к работе из коробки. Для изменения параметров антивирусного движка используются разделы:, , позволяет работать в режиме кластера. Это означает, что у вас может быть 2 почтовых шлюза (для балансировки нагрузки или отказоустойчивости). При этом режиме работы, настройки и политики применяемые на одном шлюзе синхронизируются с другим и наоборот (аналог стека у коммутаторов)., так же из коробки позволяет сделать вам кластер из , нод. Аналогией является кластер в PVE, где несколько физических гипервизоров можно объединить в кластер.,Настройка банально проста и происходит в разделе ,. Для настройки объединения нод PMG в кластер необходимо:,На мастер ноде создать кластер (нажать кнопку ,) и подождать завершения операции;,На мастер ноде нажать на кнопку , и скопировать себе , и ,;,На ноде, которую хотите добавить в кластер нажать кнопку , и ввести , и ,, скопированного с мастер-ноды.,Кластер готов. Теперь настройки применяемые на одной из нод будут применены и на другой. Все просто, не так ли?,И это все? Конечно, , нет. Данная статья рассчитана на то, чтобы познакомить вас с таким замечательным, на мой взгляд, решением, как ,. Конечно до , ему еще далеко, но из того, что предлагает , - это ,. Настройки, приведеные в статье позволяют лишь подготовить PMG для пересылки писем от внешнего отправителя на внутренний почтовый сервер и наоборот. Как я говорил в самом начале, прелесть данного решения в готовности к бою со спамом из коробки, при минимальных затратах на его настройку. Главная задача настройки сводится к ""направлению"" , через почтовый шлюз. Прелесть данного решения еще и в том, что под капотом , с , и т.д., которые уже взаимодействуют между собой. Все, что вам остается - тюнить правила и политики. Если не хватает возможностей с вебки - лезем по , на PMG, устанавливаем пакеты, конфигурируем файлы, танцуем с бубном - все в ваших руках, все как мы любим. Ну и, конечно же - чтение документации. У PMG есть свои утилиты для управления политиками, а так же Rest API.,Не забудьте указать на вашем SMTP-сервере (MTA) в качестве , - PMG с портом 26, для отправки всех писем наружу через шлюз. Так же не забудьте настроить , на вашем пограничном оборудовании, чтобы , с портом 25 указывал на 25 порт PMG. Дерзайте!,DevOps",ЧудESA защиты корпоративной почты или внедрение свободных почтовых шлюзов на базе Proxmox Mail Gateway / Хабр
[<200 https://habr.com/ru/company/productivity_inside/blog/662668/>],page2,Пользователь,Дайджест интересных материалов для мобильного разработчика #440 (18 — 24 апреля) / Хабр
[<200 https://habr.com/ru/company/audiomania/blog/662537/>],page2,"На неделе один из участников Hacker News , тематический тред с целью узнать, как «связать» компьютер, колонки и другую акустику в единую звуковую систему.,Мы решили рассмотреть несколько стандартов, которые используют музыканты в студиях, а также , решения, доступные для развертки любому аудиоману.,Участники обсуждения отметили, что в проф. среде распространены протоколы трансляции аудио по Ethernet. Их , на три категории. Первая подразумевает прямую передачу звука по классическим кабелям ,. Например, к ней относится , AES50, который , с PCM-сигналами. Его поддерживают консоли таких производителей, как Midas и Behringer.,Вторая категория позволяет настроить канал между двумя аудиоустройствами в сети. Свод стандартов — , — в той нише разработали в IEEE.,Третья категория — протоколы сетевого уровня. Они позволяют коммутировать десятки устройств одновременно. Одно из , решений такого класса — Dante. Его используют в студиях звукозаписи, офисах (для построения конференц-систем), а также в концертных залах — например, в , Сиднея. Хотя Dante представляет собой нечто большее, чем просто протокол обмена данными, он также включает драйвера для подключения к аудиоустройствам и DAW и приложения для маршрутизации аудио.,В этой группе также стоит отметить открытый стандарт ,, который , трафик по RTP (благодаря этому он может работать с аудио и видео), и AES67, , инженерами из сообщества Audio Engineering Society.,Пожалуй, наиболее распространенным протоколом для связи аудиоустройств в домашних условиях остается Bluetooth. Он закрепился в консьюмерском сегменте и используется подавляющим большинством производителей наушников, колонок и проигрывателей.,Но в случае с Bluetooth могут возникать сложности со связыванием нескольких акустических систем. Однако есть платформы, которые позволяют настроить мультирум как с проводными, так и беспроводными устройствами.,Пример такого решения — ,. Это — приложение с открытым исходным для управления парком аудиодевайсов из ,. Можно транслировать музыку на колонки, подключённые к любому устройству в сети (поддерживается Windows, MacOS, Linux и Raspberry Pi). Пока что проект находится на ранних этапах разработки, но в будущем автор планирует расширять функциональность — в частности, добавит возможность объединять устройства из нескольких сетей и интеграцию с IoT-девайсами.,Альтернативным решением может быть ,. Это — клиент-серверное приложение, которое можно использовать в паре с , или ,. С помощью подобных систем каждый может развернуть у себя дома мультирум-систему.,Пользователь",«Синхронизируй это»: компактный обзор примечательных решений и протоколов для передачи звука по Ethernet / Хабр
[<200 https://habr.com/ru/post/662684/>],page2,"Эта статья не относится к жанру официозных юбилейных публикаций. Скорее – это небольшой,  очень личный, не совсем упорядоченный и причёсанный набор воспоминаний и раздумий о пути, пройденном Машинной Графикой в в СССР и о человеке, посвятившему ей всю свою жизнь - докторе технических наук, лауреате Государственной Премии СССР, Викторе Алексеевиче Дебелове.,Уверен, что Виктора Алексеевича, учитывая его колоссальный вклад в становление советской Машинной Графики,  без особой натяжки можно было бы назвать одним из её основоположников в СССР.,Но… зная его скромность и пренебрежительное отношение к почестям и наградам, позволю себе «наградить» его в этом рассказе званием, которого он безусловно заслуживает – Рыцарь Машинной Графики.,Учась на третьем курсе Матфака НГУ я прочитав объявление, что руководитель отдела Вычислительного Центра Сибирского Отделения Академии Наук (далее в тексте -ВЦ СОАН, или просто ВЦ) Юрий Алексеевич Кузнецов приглашает студентов на экскурсию в его лабораторию.,Я записался на эту экскурсию и так впервые оказался на ВЦ.,Это было романтическое и одновременно наивное время. Пятилетние научные планы основывались скорее на полёте фантазии, а не на реальных оценках или расчётах.,Молодой руководитель отдела объяснил желторотым студентам, что на пятилетку лаборатории была поставлена задача по всей стране автоматизировать труд машинисток и лаборанток, занятых печатанием научных статей, вписыванием в них формул и отрисовкой графиков. Всё это будут делать ЭВМ! А лаборанток переведут на другие, полезные для страны работы.,Для этого уже сегодня в Лабораторию Машинной Графики, входящей в его отдел, принято много сотрудников. Но нужно ещё больше, и поэтому он охотно приглашает студентов писать здесь курсовые и дипломные работы. Ну а потом, возможно и стать сотрудником лаборатории. Забегая вперёд отмечу, что размашистые планы были реализованы с большим отставанием и увы, в основном за рубежом. Защищая почти через 10 лет диссертацию, я оплатил «в чёрную» труд машинистки и сам вписал в 5 экземпляров диссертации необходимые формулы. И рисунки пришлось вручную копировать с графиков, нарисованных на графопостроителе.,Но вернёмся к истории. Итак, я решил писать курсовую и дипломную работы по Машинной Графике и стал понемногу вливаться в коллектив отдела. И тут я удивлением обнаружил, что он состоит в основном из сотрудниц редакции ВЦ, прикрепленных к отделу, машинисток, лаборанток, роскошных секретарш… а вот людей занимающихся программированием, было очень мало.,Они кучковались вокруг троицы совсем молодых энтузиастов – Владимира Дворжеца, Сергея Горина и Виктора Дебелова. Причем авторитет Виктора уже тогда ощущался во всём.,Это был невысокий, элегантно одетый, очень молодой и очень энергичный человек. Познакомившись с ним позже поближе, я был поражен его глубинным знанием мельчайших технических деталей профессии. Очень впечатляла его способность не только параллельно думать над несколькими вещами, но и одновременно разговаривать с несколькими людьми.Выглядело это так – Виктор Алексеевич и пара молодых сотрудников сидели за своими столами друг напротив друга и занимались проектированием или программированием какого-нибудь модуля системы. При этом они “в режиме реального времени” обсуждали свои проблемы. А в это время в комнату постоянно заходили другие люди, о чем-то спрашивали или просили Виктора Алексеевича. А он, как фокусник в номере с крутящимися тарелками, умудрялся мгновенно переключаться с темы на тему и ещё делать свои дела, не сбавляя темпа.,В первые годы, когда я писал в лаборатории курсовую и дипломную работы, работал стажёром и младшим научным сотрудником, Виктор Алексеевич никогда не был моим формальным руководителем. Но именно его я считаю своим Учителем Машинной Графики.,Он обладал поразительным умением быстро вникнуть в задачу, «разгрести» технические проблемы и направить ход мыслей молодого коллеги в нужном направлении. Причём происходило это как-то ненавязчиво, как бы между делом, однако помощь его молодым сотрудником было невозможно переоценить.,Увы, при всех талантах Виктора Алексеевича, ему тогда не было предназначено судьбой стать руководителем лаборатории или отдела на ВЦ. В те времена каждый новый руководитель академического подразделения, от института до отдела, первым делом ставил на руководящие посты своих близких сотрудников или аспирантов. Кроме того, Виктор Алексеевич не был ни членом партии ни активным общественником. Внимательный и терпеливый по отношению к молодым сотрудникам и студентам, он не лез за словом в карман при оценке часто трудно объяснимых решений руководства. И вообще он плохо вписывался во всё более загнивающую академическую систему. Он был профессионалом высочайшего уровня, но увы, тогда это было уже отнюдь не главным критерием для занятия постов. Опять забегая вперёд отметим, что спустя много-много лет, когда уже распался СССР, ВЦ СОАН несколько раз переименовали и перепрофилировали, Виктор Алексеевич всё-таки дал себя уговорить и возглавил изрядно поредевшую (практически опустевшую) лабораторию, в которой проработал всю жизнь.,В 70-е годы нужно было буквально изобретать с нуля различные аппаратные и программные компоненты Машинной Графики. И тут открылся новый талант Виктора Алексеевича – организатора межинститутских и межотраслевых проектов и научно-технических конференций.,Нынешним учёным и инженерам очень трудно представить себе ситуацию и атмосферу того времени. Непосредственные контакты и общение профессионалов между собой были тогда основным источником профессиональной информации. Компетентность была «лакмусовой бумажкой» сближавшей творческих и инициативных людей того времени. Патриарх Машинной Графики в СССР Юрий Матвеевич Баяковский и Виктор Алексеевич были центрами притяжения и катализаторами всех тогдашних всесоюзных и региональных конференций. И хотя организация конференций и симпозиумов, участие в их Оргкомитетах отнимали массу времени и сил, Виктор Алексеевич всю свою профессиональную жизнь с увлечением занимался этим. Прошли годы, и это дало свои плоды. Несмотря на прохладное отношение к Машинной Графике со стороны академических и отраслевых руководителей, прошедшие через эти конференции специалисты организовали лаборатории и фирмы в различных областях компьютерной графики и компьютерных игр, некоторые из которых выдавали и выдают очень интересные научно-технические результаты и продукты.,В то время научные сотрудники делились на две категории по роду своей деятельности: тех кто «двигает науку», т.е. пишет научные статьи и тех, кто зарабатывает институту деньги, выполняя так называемые хоздоговора (договора с предприятиями на выполнение научно-технических услуг, например – установку программного обеспечения и обучение сотрудников). Улучшение и расширение существующего программного кода, консультации пользователей системы, устранение найденных ошибок не входили ни в первую, ни во вторую категорию и не приветствовалось. Виктор Алексеевич находил тем не менее время заниматься сам и привлекал других сотрудников к этим занятиям, настаивая на необходимости постоянной «заботы» о системе. Сейчас это кажется очевидным и выражается в виде концепции DevOps (Development & Operation). В то время отстаивание этого подхода требовало от него не только прозорливости, но определённой храбрости выступать против указаний руководства.,Он хорошо представлял себе уже тогда, какое огромное значение приобретёт компьютерная (тогда машинная) графика в общении человека и машины и удивлял всех нас радикально новыми идеями и направлениями работы. Как правило, каждое превращение идеи в продукт он начинал со студенческих курсовых и дипломных работ, предлагая студентам совсем новые, незнакомые и ему самому темы. Этим он разительно отличался от многих остальных руководителей дипломных и курсовых работ, нередко перекладывавших на курсовиков и дипломников рутинные задачи из собственной тематики, которыми им самим заниматься не хотелось,Но вернемся в 70-е годы. В то время гордостью ВЦ была система коллективного пользования немногочисленными ЭВМ, включая возможность отрисовки научных графиков на графопостроителях. Последнее достигалось за счёт использования библиотеки программ с запоминаемым названием СМОГ, что расшифровывалось как Система Математического Обеспечения Графопостроителей.,Бесспорными лидерами в области научной визуализации на тот момент были две системы – московская система ГРАФОР (Графическое расширение Фортрана) и сибирская СМОГ. Причём у суровых производственников, особенно в так называемых ящиках (оборонных конструкторских бюро), СМОГу отдавалось предпочтение за его надёжность и многофункциональность.,Видимо, столь широкое распространение СМОГа, особенно на предприятиях оборонных отраслей, послужило причиной огромного доверия, оказанного очень малочисленному коллективу Лаборатории Машинной Графики ВЦ – разработать для ряда оборонных министерств Базовую Систему Машинной Графики для Систем Автоматизации Проектирования в машиностроении.,Эта задача была записана в пятилетний план СО АН. В соответствии с тогдашней традицией систему решили назвать СМОГ-85.,В то время я был совсем молодым сотрудником, но часто должен был летать из Новосибирска в Москву на заседания и обсуждения Технического Задания (ТЗ) на СМОГ-85 в разные отраслевые институты и предприятия. ТЗ надо было написать, обсудить, утвердить и заверить подписью у какого-то невероятного числа начальников. В основном этом занимались Александр Михайлович Мацокин, незадолго до этого назначенный заведующим отдела, переименованного в Отдел Автоматизации Проектирования и Машинной Графики, Виктор Алексеевич Дебелов и я.,Каждое предприятие было тогда самодостаточным и имело всё – от необходимого для работы до собственных столовых, детских садов, санаториев и гостиниц. Приехав в командировку, надо было заселится в гостиницу принимающего предприятия, которая, как это ни абсурдно звучит, иногда тоже была секретной.,Например, могли выдать распоряжение на поселение в гостиницу по адресу типа: Улица Калинина, дом 12, квартира 49. Ты находишь этот дом, поднимаешься на третий этаж, звонишь в квартиру 49. Тебе открывают дверь, и ты понимаешь, что весь этаж этого жилого дома состоит не из квартир, а из гостиничных номеров, выходящих в единый длинный коридор.,Вход для посетителей на само предприятие мог быть «закамуфлирован» вывеской «Мелькомбинат N12“ или чем- то подобным. Но иногда этот «камуфляж» давал «предательские проколы».,Вспоминается такой весёлый случай. Как-то мы с Виктор Алексеевичем прилетели в Москву на совещание, которое должно было состояться в закрытом отраслевом институте, в котором мы никогда до этого не были. Мы знали адрес и знали ближайшую станцию метро. Напомню, что никаких навигаторов тогда не было и в помине, а карты бумажные Москвы были… скажем так – очень приблизительны.,Мы доехали на Метро до нужной станции, быстро нашли нужную улицу и пошли по ней. По номерам домов ожидалось, что мы близки к цели. Но увы, за одним номером мог скрываться целый квартал каких-то зданий, обнесённых единым забором. И хотя мы выехали из гостиницы заранее, у меня стало нарастать опасение, что к началу совещания мы не успеем. Этим опасением я поделился с Виктором Алексеевичем. Но он меня успокоил:,-Не волнуйся, успеем. Вон в том здании они располагаются.,– Откуда ты это знаешь, ты ведь там никогда не был?,– Похоже они в Радиопроме (Министерство Радиопромышленности) все новые административные здания строятся по одному типовому проекту. Мы с тобой были точно в таком же.,Я присмотрелся – и точно. И прогноз его сбылся.,Печаль ситуации состоял в том, что взявшийся за выполнение такого колоссального задания ВЦ был не в состоянии «переварить» свалившуюся на него задачу и… финансирование. Для его выполнения были нужны специалисты. Много специалистов. Но ВЦ не мог принять новых сотрудников, поскольку это определялось совсем другим пятилетним планом. Небольшая поддержка была оказана Научно-Исследовательским Сектором НГУ. По этой линии было принято несколько новых сотрудников, усиливших коллектив.,Сегодня индустрия ИТ может относительно хорошо оценивать трудоёмкость программных проектов. Остаётся только удивляться, что столь малочисленный коллектив лаборатории не только создал работоспособную систему, но и разработал массу оригинальных алгоритмов высокой научной пробы.,Выражаясь современным языком, Виктор Алексеевич в проекте СМОГ-85 взял на себя роль архитектора и тимлида системы (хотя понимания такой роли у нас тогда не было). И кроме того, он вместе с безвременно ушедшим из жизни Сергеем Александровичем Упольниковым разработал трехмерную часть проекта.,Система СМОГ-85 была успешно разработана и внедрена на головных предприятиях ряда оборонных министерств:,– Конструкторском Бюро Машиностроения (КБМ, г. Коломна),,– Московском Институте Теплотехники (МИТ),,– НПО “Стрела” (г. Тула),,– Новосибирском Авиационном Заводе им. Чкалова,и ряде других.,Увы, данные о реальном вкладе СМОГ-85 в ускорении разработки изделий, над которыми работали тогда эти предприятия, осели в до сих пор не открытых архивах. Но Википедия и другие источники нам подсказывают, что КБМ в те годы разрабатывало стоящий до сих пор на вооружении комплекс «Искандер», МИТ -ракету «Булава», НПО “Стрела” – комплексы “С-300”, а Новосибирский Авиазавод выпускал самолёты Су-32.,Виной отсутствия информации о реалиях применения СМОГ-85 является всё та же секретность тех времён.Тем не менее, разработчикам сообщили, что СМОГ-85 позволил резко ускорить проектирование за счёт замены физического макетирования изделий моделированием.,По результатам внедрения и использования СМОГ и СМОГ-85 Виктор Алексеевич Дебелов был награждён Государственной Премией СССР, а ещё два участника разработки СМОГ-85, в том числе автор этих строк – Премиями Совета Министров СССР.,В сложной ситуации начала лихих 90-х, когда учёным месяцами не платили зарплату, а другие каналы финансирования в одночасье пересохли, личная известность и авторитет Виктора Алексеевича позволили коллективу сплотившихся вокруг него специалистов как-то пережить эти тяжёлые годы. Воспользовавшись просто-таки безысходным положением советских  специалистов, японская фирма «Интегра», что называется «на корню» скупила ведущих советских специалистов по Машинной Графике, среди них – почти всех разработчиков «СМОГ/СМОГ-85».,Так мы «впрыгнули» в жесткий капиталистический рынок.,Правда, длилось это не очень вольное с нашей стороны сотрудничество только пару лет. Фирма постоянно ужесточала «нормы выработки», пока автор этих строк и затем Виктор Алексеевич её не покинули.,Каждый из нас пошёл своим путём. Правда, мы соединились в 2000 году, чтобы написать вместе книгу по  DirectX, которая вышла на немецком языке в одном из самых солидных на тот момент издательств научно-технической литературы – Addison Wesley.,Виктор Алексеевич Дебелов всю свою жизнь оставался и остаётся верен своему призванию – Машинной Графике. В тяжелейшие годы он не бросился в бизнес, а  полностью посвятил себя науке и преподаванию Машинной Графики в НГУ.,Знания и научная прозорливость Виктора Алексеевича оказались востребованы и за пределами России. Заказчиками его научных проектов в последних десятилетий были как гиганты европейской и азиатской индустрии, так и ведущие российские предприятия.,В последние годы он интенсивно разрабатывает очень специальное направление компьютерной графики – симуляции оптических процессов в анизотропных кристаллах. В этой области он стал на международной арене бесспорным авторитетом.,Уверен, что сотни студентов и десятки аспирантов и дипломников, «прошедших через руки» Виктора Алексеевича, с теплотой и благодарностью вспоминают об этом одновременно строгом и доброжелательном Учителе и Наставнике.,От их имени, от имени многочисленных коллег и от себя лично хочется пожелать Виктору Алексеевичу Сибирского Здоровья, неистощимого потока новых идей и главное – по прежнему оставаться преданным Рыцарем Машинной Графики.,...,Эта статья из моего открытого книжного проекта ,. ,Если интересно - заходите.,Debelov V.A.; etc. Multi-Purpose Computer Graphics System SMOG 85. Computers and Graphics.1988. vol. 12. N. 3/4 ,Debeloff V., etc. DirectX programming with Visual C++. Addison Wesley. ISBN 3-8273-1389-9. 495 S. CD-ROM. (,).,Системная Архитектура, Программирование",Рыцарь Машинной Графики / Хабр
[<200 https://habr.com/ru/company/skillfactory/blog/662686/>],page2,"Автор ускорил сложение векторов до ~12 000 000 сложений 1024-мерных векторов в секунду. Делимся подробностями и представляем генератор WASM из С++ от автора статьи к старту курса по ,.,Код запускался на M1 MacBook Air с node.js 17, весь код ,.,Это медленно. Попробуем размеры 4, 64, 1024:,Это будет базовое значение (~15 Гб/с).,Вместо скучного Array используем Float32Array. Типизированная версия покажет V8 в деле. Кроме того, Array использует double, float — в два раза меньше. Надо только поменять вызовы инициализации:,Получим:,Ух... Вызовы типизированных массивов быстрее, чем 11 Гб/с, даже на больших размерах:,Похоже, JIT хорошо работает с массивами JavaScript. Это видно по отключению прогрева в тесте:,Как это делается, , в посте блога команды V8. Агрегированный тип Array отслеживается, т. е. подсказка типа от типизированных массивов не даёт большого преимущества, а float — меньше по размеру, так что причина происходящего непонятна. ,Решение предложил , на HackerNews: сложение выполняется с двойной точностью и с преобразованиями на каждом этапе. Float64Array даёт ускорение, позволяя догнать чистый JavaScript. В Firefox движок JavaScript не такой, как в node.js и Chromium, отсюда типизированные массивы быстрее. Это заметил ,. Спасибо!,Emscripten — это фреймворк, который сразу компилирует C и C++ в WebAssembly и берёт на себя тяжёлую работу, для совместимости оборачивает системные вызовы и вызовы стандартной библиотеки C.,WebAssembly — это простой набор инструкций, производительность которых близка к нативной. , спецификация его ядра.,WebAssembly не только прост, но и безопасен, что немного затрудняет работу с большими объёмами памяти: у каждого экземпляра WebAssembly своя линейная память. Единственная функция «из коробки» здесь (Memory.grow) похожа на mmap и, уже не настолько, на malloc:,На самом деле в Emscripten malloc реализован, но памятью владеет экземпляр WebAssembly, в котором нужно складывать вектора. Вот типичная функция Emscripten:,Код выше использует malloc в Emscripten заставляет JavaScript интерпретировать этот указатель как смещение в кучу Emscripten. Это даёт две переменные, которые ссылаются на одну и ту же память: последнюю можно передать вызовам Emscripten, а первую — использовать как типизированный массив.,Запустим только что написанный модуль Emscripten с флагом оптимизации -O3:,На малых размерах скорость по-прежнему невысокая, но у размера 1024 заметно ускорение:,Одна инструкция одновременного процессора обрабатывает несколько элементов. WebAssembly отчасти поддерживает такие инструкции — SIMD. Чтобы воспользоваться SIMD, скомпилируем код с флагом -msimd128; хорошее ускорение:,75 Гб/с! Но ещё есть где прибавить. Например, при запуске функции, работающей с вектором любого размера. Можно ли оптимизировать что-то ещё, если при тестировании ограничить функцию размером вектора?,Работать на C++ с Emscripten — это круто, и в 99 % случаев этот рабочий процесс незаменим, но именно здесь пойдём дальше: генерируем код динамически. К сожалению, на компиляцию в Emscripten часто уходят секунды, а в крупных проектах — минуты, поэтому я написал заголовочный файл, генерирующий чистый WebAssembly прямо из C++ — это ,. ,Большинство вызовов занимает 1,5 микросекунды, потому что представлена спецификация с семантикой C++. Чтобы инстанцировать модуль WebAssembly, нужно 125 микросекунд, поэтому у нас около 8000 перекомпиляций в секунду, что намного быстрее Emscripten.,Зная размер цикла, можно развернуть его. Развёртывание часто используется, чтобы убрать инструкции для циклов и арифметику указателей. В wasmblr все вызовы cg.* создают сборку, а значит, для загрузки, добавления и хранения каждого элемента в векторах можно использовать циклы C++, это нечто вроде метапрограммирования.,Поясню кое-что в коде.,Переменная pages. В wasmblr нет вызываемой из JavaScript реализации malloc. Поэтому пришлось поработать с предварительным распределением полного размера ввода и вывода (2 ввода, 1 вывод, 4 байта с плавающей точкой, все длины len, размер страницы 1<<16).,Что делает cg.local.get(2) наверху? cg.local.get(X) ссылается на аргументы, это — ссылка на третий аргумент, то есть наш вывод. Вызываем его наверху, потому что он нужен для пути cg.v128.store внизу как аргумент в стеке. WebAssembly — это скорее набор инструкций стека, чем регистра, поэтому читать его странно.,load и store принимают непосредственные аргументы. Это часть спецификации WebAssembly. В load/store можно жёстко задать смещение, и оно будет добавлено к указателю в стеке. Вместо того чтобы жёстко задать 0 и добавлять указатели на память, можно просто оставить указатели и поместить смещения в сам код. В Emscripten это было бы невозможно, ведь сгенерированный код должен обрабатывать все типы длин.,Для выбранных размеров результаты хорошие: в 2 раза больше, чем в Emscripten. В последнем тесте скорость уже 154 Гб/с!,А как насчёт размеров больше?,Должно быть, мы выпали из кеша инструкций. У развёртки есть пределы, и мы зашли слишком далеко, выпустив для простого цикла for программу размером ~100 Кб. Придётся идти непростым путём и следить за указателями:,Теперь выполним развёртку с коэффициентом разумнее — 16:,Похоже, работа бесполезная: производительность для размера 1024 упала! Мы наверняка увеличим её, подобрав коэффициент развёртки.,Но зачем делать это вручную, когда на перекомпиляцию и перезагрузку кода wasmblr нужно 1/8000 секунды? Лучше просто сравнить коэффициенты и сохранить лучший:,Добавим ещё один тест. Чем больше размерность векторов, тем меньше оперативной памяти и больше возможностей у инструкций, поэтому стоит ожидать выравнивания:,Благодаря настройке удалось восстановить идеальные показатели для размера 16 384, а на определённых размерах даже улучшить их и не выпасть из кеша. На размере 262 144 действия уже не слишком важны: векторы так велики, что мы просто ждём в памяти почти всё время.,Для небольших векторов подойдёт чистый JavaScript. Если же векторы больше кеша, отлично справится Emscripten. А когда размер очень специфический и у вас много времени, воспользуйтесь wasmblr. Спасибо за внимание!,А мы поможем вам прокачать навыки или освоить профессию, востребованную в любое время:,Выбрать другую ,.,Пользователь",Сложение векторов со скоростью 154 Гб/с на WebAssembly / Хабр
[<200 https://habr.com/ru/post/662680/>],page2,"?,?,?,?,?,?,?,?,?,Эта статья открывает серию публикаций по обучению фреймворку $mol. Сегодня мы разберемся в модульной системе MAM. Речь пойдет об организации кода, отделении его от инфраструктуры, сборке, версионировании, нейминге, минимизации размера бандла, автоматическом выкачивании зависимостей, фрактальных моно-поли-репозиториях, разделении кода на платформы, альтернативе импортам/экспортам, автоматическом разруливании циклических зависимостей.,$mol - высокоуровневый веб-фреймворк, который переосмысливает общепринятые подходы. Одновременно с этим это набор узкоспециализированных, подогнанных друг к другу модулей. Популярные высокоуровневые фреймворки ассоциируются с неповоротливостью и сложной кастомизацией. $mol спроектирован так, что можно быстро собрать интерфейс как на высокоуровневом фреймворке, при этом гибкость кастомизации превосходит низкоуровневые фреймворки.,Для кого-то богатство экосистемы фреймворка является определяющим фактором. В $mol много модулей, они закрывают большинство потребностей. Недостающие можно собрать из существующих или использовать npm.,Как это не парадоксально звучит, но чем больше у вас опыта, тем сложнее освоить $mol. В нем используется много непривычных подходов, которые при первом знакомстве вызывают отторжение. Но стоит их переварить и становится непонятно, как жилось без этого раньше.,MAM - это модульная система, в которой живут модули $mol. Абстрактный модуль - это директория с файлами, которые его реализуют. MAM - это набор правил, ограничений и принципов, которые  превращают код в кубики LEGO.,Изучение $mol, лучше начинать с MAM. Разберитесь как использовать модули на практике, а затем приступите к знакомству с системой реактивности.,Если вы знаете, как работает Mobx, то уже представляете как работает система реактивности в $mol. Тут она используется на всех уровнях, а не только на уровне представления.,В отличие от архитектуры потока управления, в $mol реализована архитектура потока данных. Приложение определяется как набор классов с реактивными свойствами. Свойство представляет собой метод с реактивным декоратором. Каждое свойство определяется как некоторая функция от других свойств. Результат выполнения свойств кэшируется.,При вызове, реактивное свойство запоминают к каким свойствам оно обращалось во время выполнения, и кто к нему обращался.,Когда какое-то свойство меняет свое значение, зависимые от него свойства помечаются устаревшими. Если получить значение устаревшего свойства, произойдет актуализация помеченного поддерева и свойство вернет актуальный результат. Если обратиться к свойству в актуальном состоянии, оно вернет результат из кэша.,Всё приложение на этапе выполнения представляет собой большое дерево зависимостей. Каждое свойство знает свои зависимости, это дает простой и надежный механизм управления жизненным циклом объектов - они создаются, когда появляется зависимость, и уничтожаются, когда от них ничего не зависит. Это решает две фундаментальные проблемы: утечки памяти и инвалидацию кэша.,После того как вы разберетесь с реактивностью, можно переходить к view-компонентам, из них строится пользовательский интерфейс.,В $mol компонент состоит из нескольких частей, а каждая часть, находится в отдельном файле, можно выделить 5 частей:,Декларативное описание интерфейса компонента и потоков данных(обязательное, остальное опционально),Императивное поведение компонента,Стили,Локализация,Тесты,Есть базовый класс , с набором свойств, такими как события, атрибуты, дети и т.д. Он является оберткой над одним DOM-элементом. Когда любое из его свойств становится неактуальным, реактивная система автоматически вызывает его актуализацию, что точечно обновляет элемент в DOM-дереве.,Пользовательские компоненты, наследуются от базового класса, и настраивают его компоновку и поведение.,Для описания компонент используется язык ,. С виду он выглядит сложными и нечитаемым, но это только с первого взгляда, точно такое же впечатление производит ,, когда видишь его впервые. Но , не ,, там всего порядка 10 операторов, на изучение которых необходимо несколько часов. Он не является шаблоном в общепринятом понимании, это ближе к интерфейсам в ,.,С помощью , мы говорим:,как называется наш компонент,от какого компонента он наследуется,какими компонентами он владеет,как эти компоненты компонуются в его ,какие состояния имеет компонент,какими потоками данных связаны компоненты и состояния,Сборщик из , описания генерирует класс, от которого можно отнаследоваться и добавить поведение.,MAM - модульная система, в которой переосмыслена работа с кодом и его организация. Она проектировалась для единообразной работы с произвольными объемами кода, облегчая переиспользование и минимизируя рутину.,MAM расшифровывается как ,.,Модуль - директория, внутри которой находятся файлы реализующие его. Разные части модуля находятся в разных файлах. Абстрактный - значит, что модуль не привязан к какому-то конкретному языку, а может быть реализован на нескольких. Модуль первичен, а технологии на которых он реализован - вторичны.,Особенности:,Один модуль - одна директория,Модули произвольно вкладываются друг в друга, все есть модуль,Имя модуля - путь до него в файловой системе,Модуль может выступать пространством имен - содержать только директории,Зависимости между модулями отслеживаются автоматически,Разные типы исходников модуля, попадают в разные бандлы,Можно провести аналогию с ,, там используется термин ""блок"", первичен блок, его реализация вторична.,В MAM нет пользовательского конфига, вместо него используются соглашения. Соглашение можно рассматривать как некое условие, которое нужно выполнить, чтобы получить требуемый результат.,С одной стороны это позволяет просто установить MAM и стартовать проект без дополнительных действий, т.к. уже все настроено. С другой стороны, отсутствие конфигов, позволяет независимым разработчикам писать единообразные модули, которые будут работать друг с другом без дополнительных усилий, на уровне модульной системы.,Компания может разрабатывать больше одного приложения. Нередко инфраструктура сборки, разработки, деплоя разворачивается для каждого из них. Инфраструктура развивается эволюционно от приложения к приложению, путем копирования и доработки. Перенос доработок в старые приложения оказывается трудоемким.,MAM поставляется в отдельном репозитории, в котором настроено рабочее окружение. Работа со множеством проектов осуществляется в одном окружении. Вы можете централизовано получать обновления для окружения и централизовано вносить изменения во все приложения.,В начале у нас один репозиторий с проектом. Когда он разрастется, часть можно вынести в отдельный репозиторий. Репозитории могут образовывать дерево, вкладываясь друг в друга. При разделении на несколько репозиториев, код остается неизменным, добавляется только ссылка на удаленный репозиторий. MAM автоматически клонирует нужные для проекта репозитории. Локально код всех приложений выглядит как один моно-репозиторий.,Подход к версионированию в MAM называется ""verless"" - безверсионность. Он работает по принципу открытости/закрытости.,Модуль всегда имеет одну версию - последнюю.,Версии которые сохраняют обратную совместимость API, публикуются под одним именем - рефакторинг, фиксы, расширение.,Не совместимые, под разными именами - ,.,Реализация старого интерфейса, может использовать новую реализацию (или наоборот), что предотвращает дублирование.,Что это дает:,Мейнтейнер и пользователи модуля фокусируются на одной ""версии"", вместо  распыления внимания на несколько.,Несколько ""версий"" одного модуля могут сосуществовать рядом. Возможна плавная миграция.,При использовании двух ""версий"" одного модуля, размер бандла увеличится только на размер адаптера.,Важную функциональность необходимо покрывать тестами.,В случае, если обновление что-то ломает, фиксация ревизии обеспечивается системой контроля версий.,Любой модуль можно собрать независимо, без предварительной подготовки. Сборщик автоматически установит недостающие зависимости и скачает удаленные репозитории, от которых зависит собираемый модуль. Артефакты помещаются в директорию , (минус) , которая создается в папке с модулем.,Далее будем называть директорию, в которую помещаются артефакты сборки - дистрибутив. А отдельный артефакт в ней - бандл.,MAM накладывает ограничение на имена глобальных сущностей. Чтобы сущность можно было использовать в других модулях, ее имя должно:,Через знак подчеркивания, повторять путь до этого модуля в файловой системе,Начинаться с , (не во всех языках такое возможно, в ts/js - да, в css - нет),Примеры: ,, ,, ,Такое именование называется , - оно позволяют однозначно идентифицировать сущность, независимо от контекста ее использования.,Это ограничение позволяет:,Лучше продумывать имена модулей и структуру приложения,Разработчик всегда знает, что где лежит,Делает имена глобально-уникальными,Упрощает анализ кода,IDE умеют генерировать импорты автоматически, что мешает делать это сборщику? В MAM не нужно использовать импорты/экспорты, чтобы воспользоваться сущностью из другого модуля, достаточно просто написать ее имя.,Сборщик по FQN-именам понимает где и какой модуль используется, и автоматически их подключает при сборке.,Чтобы код максимально переиспользовался, он должен быть разбит на множество маленьких, специализированных модулей.,Для этого нужно, простое создание и использование модулей. В MAM для создания модуля, достаточно создать директорию с файлом, а для использования обратится к FQN-имени.,Так как модули имеют высокую гранулированность, а в сборке участвуют только зависимые модули, то бандлы имеют минимальный размер.,Для разных вещей используются разные языки: ,, ,, ,, ,, ,, и т.д. Например в webpack, точкой входа является скрипт, в котором подключаются файлы на остальных языках. А что если модуль состоит только из ,?,В MAM модульная система отделена от языков, т.е. зависимости могут быть кросс-языковыми. , может зависеть от ,, который зависит от ,. В исходниках обнаруживаются зависимости от модулей, а модули подключаются целиком(все файлы) и могут содержать исходники на любых языках - точнее на тех, которые сейчас поддерживает MAM, но есть возможность расширить их список.,Каждый файл модуля специализируется на чем-то своем, предназначение файла отражено в его имени. А в дистрибутив сборщик кладет несколько разных типов бандлов.,Например:, - код из этого файла попадет только в бандл , - код попадет только в бандл , - попадет в оба бандла , и , - попадет в бандл с тестами , и ,., - также можно у платформу,, , - файлы локализации для русского и английского,Подробный разбор того какие файлы модуля поддерживаются MAM и какие бандлы создаются в дистрибутиве производится ниже.,MAM создает дополнительные бандлы с тестами , и ,. В них добавляется код приложения и код тестов(для , это не совсем так, объясняется ниже), тесты создаются в файлах ,. При запуске тестового бандла, исполняется код приложения, после него запускаются тесты.,При падении теста, под подозрением оказываются: тест, модуль для которого написан тест и зависимости этого модуля. Сборщик MAM строит граф зависимостей модулей и перед запуском сортирует тесты по глубине, от меньшей к большей. Такой подход гарантирует, что при запуске тестов модуля, его зависимости уже протестированы - под подозрением остаются только тест и модуль.,При разработке, следует запускать тестовые бандлы. Тесты запускаются после каждой сборки, в отладчике следует поставить остановку на ошибках, чтобы раньше выявлять проблемы.,В NPM-пакетах можно встретить ситуацию, что код который запускается во время разработки отличается от кода, который публикуется. Ситуация когда ошибка воспроизводится только на production не исключительна. MAM специально не преобразует код в production бандлах, при разработке запускается тот же код. Отличие только в том, что в тестовые бандлы добавляется код тестов.,Далее, на примере небольшого веб-приложения - счетчик, мы попробуем MAM на практике и разберем подробности его работы. В следующих частях цикла к этому  приложению добавим реактивность и переведем его на $mol-компоненты.,Обновите NodeJS до LTS версии,Загрузите репозиторий MAM,Установите зависимости, вашим пакетным менеджером,Установите плагины для VSCode ,Можно использовать ,, окружение установится автоматически, согласитесь установить плагины. ,Репозиторий с MAM-окружением зависит от NPM-пакета ,. Этот пакет является модулем ,, который опубликован в NPM, исходники модуля ,. Вся логика MAM сейчас реализована в этом модуле. Сам модуль создан одним из первых и нуждается в рефакторинге. Есть , новой версии, но пока нет ресурсов для его завершения.,Подумать над именем,Создать директорию с файлом,Условно, модули можно разделить на три типа:, - модуль, который содержит только другие модули, - директория с файлами и другими модулями, - модуль внутри другого модуля Один и тот же модуль в разных контекстах можно назвать и тем и другим.,, он  годится для примеров, но не рекомендуется использовать его для разработки, чтобы можно было делится кодом. Рекомендуется придумать свое имя.,Создадим неймспейс и модуль:,Перейдите в директорию с MAM - ,Создайте директорию для неймспейса - ,Создайте директорию для модуля приложения - ,MAM возник вместе с $mol и часть файлов заточена под него. Но в целом, ограничений нет, при необходимости можно добавить поддержку других, например ,.,Ниже перечислены файлы, которые могут размещаться в модуле и с которыми на данный момент умеет работать MAM., Это обычный ,, который может содержать произвольную разметку. Он является точкой входа для бандла ,, в нем определяется корневой DOM-элемент, к которому будет монтироваться приложение., в корневом неймспейсе, только в его модулях и глубже, Сборщик автоматически генерирует ,. Он поможет при публикации модуля в NPM и при разработке под NodeJS - информация о зависимостях и некоторая другая генерируется автоматически.,В директории модуля можно разместить файл , с необходимым содержимым, тогда сборщик , его со сгенерированным ,., Используется для документации модулей. Если модуль еще разрабатывается, добавьте строку ,. При сборке модуля, этот файл копируется в дистрибутив. Если он отсутствует, то сборщик ищет файл , в родительском модуле и так рекурсивно до корня. ,., Код на typesctipt, Код на javascript тоже поддерживается, но необходимо перед расширением добавлять , (javascript abstract module). ,., Для разделения кода по платформам используются теги , и ,. Если тег указан, то код попадет в указанный бандл, , или ,. Если тег не указан, то код попадет в оба бандла., Код в файле с тегом , попадет в тестовый бандл, их тоже два , и ,. В месте с тегом ,, можно указывать тег платформы - ,., Произвольный , код. В FQN-именах у , - знак , не ставится в начале., ,, можно использовать только с компонентами $mol., Декларативное  описания view-компонент, используется в $mol. Можно использовать для описания любых классов.,*, Локализованные тексты на разных языках, используется в $mol. Тег , принимает параметр - язык текстов, например ,., Файл с инструкциями для сборщика, поддерживает несколько команд:, - копирует указанный файл в дистрибутив, и , - включает указанный модуль в зависимости, даже если в коде он не используется., - указывает адрес удаленного репозитория для подмодуля, В $mol принято файлам реализующим view-компонент, добавлять тег , - ,, ,, ,. У формата ,, , - это не тег, а часть расширения.,Все теги - это часть составного расширения. Если читать расширение справа налево, получится конкретизация от общего к частному.,Обычно файлам дают имя модуля, например ,, ,, , для файлов в модуле ,. Но сборщику не важны их имена, он читает все файлы модуля, которые поддерживает. Важно как называются сущности внутри них, например класс компонента , в коде должен называться ,.,, ,, , - называются всегда одинаково.,Создайте файл , с таким содержимым:,Создайте  ,, весь код приведенный ниже поместите в него. Позже мы его разделим на модули.,Класс View - обертка для DOM элемента, предоставляющая интерфейс для упрощения работы с ним.,Функция , рендерит дочерние элементы, без лишних вставок и удалений в DOM-дереве. Сейчас нам нет смысла ее реализовывать, поэтому воспользуемся готовой из $mol.,Теперь создадим несколько компонентов на базе класса View. Мы наследуемся от него, переопределяем нужные методы.,И добавляем класс с логикой приложения.,Сборка запускается командой  ,. При ручном запуске, сборщик собирает все бандлы, которые поддерживает.,Соберите приложение,После запуска, сборщик вернет ошибку , для строки ,. Обратите внимание на имя файла ,, он , запускается автоматически сразу после сборки.,У нас в коде, после объявления класса Counter, запускается статический метод ,. Внутри него есть обращение к ,, т.к. , запускается под NodeJS, мы получаем ошибку.,Сейчас мы добавим костыль, позже исправим. Добавьте строку в начало метода ,Запустите сборку снова.,Выше мы уже говорили, что бандлы помещаются в директорию ,, она создается в директории модуля. Также вы можете увидеть еще несколько директорий название которых начинается со знака минус ,, ,, , - это промежуточные результаты, они создаются по необходимости.,Когда модуль выносится в отдельный репозиторий в , достаточно добавить строку ,Теперь заглянем в директорию дистрибутива ,., Это точка входа, для запуска модуля в браузере. Если файл , создан в модуле, то он будет просто скопирован. Автоматически сборщик не создает его.,Файл , создается всегда, не зависимо от наличия ,. Он нужен для того чтобы запустить тесты в браузере. Если , отсутствует, то , генерируется автоматически, с таким контентом:,Тут подключается , файл, он содержит код модуля и зависимостей. Файл , - небольшой ,, открывает соединение по веб-сокетам с дев-сервером и по его команде перезагружает страницу. По событию , загружается , - тесты для браузера и , - выводит в лог ошибки типов typescript.,Тесты запускаются при каждой перезагрузки страницы, это нужно для раннего выявления проблем.,Если есть ,, его содержимое копируется в , и часть начиная с загрузки , добавляется в конец., содержит код собираемого модуля и код модулей от которых зависит,  source map, тоже самое, только в формате , модуля, файл с декларациями typescript типов, содержит тесты модуля и тесты его зависимостей, самого кода модуля и его зависимостей в нем нет, т.к. в , файл , подгружается отдельно, сюда складываются деклорации из всех , файлов, локализация на английском, генерируется автоматически путем анализа ,, для других языков этот файл копируется, переводится и помещается в директорию с модулем., локализация для других языков, просто копируется из директории модуля в дистрибутив., информация о графе зависимостей модулей, в случае ошибок в проверке типов, тут будет , с информацией о них. Если ошибок нет, то , Все файлы с префиксом , предназначены для запуска под NodeJS. Список файлов, точно такой же как и для браузера. Отличие только в коде, т.е. исходный код файлов с тегом , попадает только в серверные бандлы, а с тегом , только в браузерные., содержит и код модуля с зависимостями и тесты к ним, в отличие от ,., Копируется из директории с модулем, если в модуле его нет, то ищется в родительском модуле и так до корня., Сборщик автоматически генерирует файл ,, используется для публикации пакетов в NPM и для серверных приложений. Если приложение использует NPM-пакеты, то они будут указаны в зависимостях. Если этот файл присутствует в модуле, то он буде объединен со сгенерированным файлом.,Давайте запустим дев-сервер, он перезапускает сборку при изменении зависимостей модуля и перезагружает страницу в браузере.,Выполните команду:,Ссылка , появится в терминале. Откройте ее, вы увидите в файловом менеджере директории находящиеся в  ,. Откройте модуль приложения ,. Обнаружив файл ,, дев-сервер начнет сборку этого модуля.,На текущий момент, поддерживается пересборка только для модулей содержащих файл ,.,Когда вы откроете модуль c файлом ,, в адресной строке браузера будет путь ,. Он состоит из:,путь до модуля, который вы собираете ,,,директория дистрибутива ,запрашиваемый бандл ,После того как браузер загрузит , документ, начнется загрузка , файла, ссылка на который находится в теге ,  - ,. Браузер сделает запрос по такому адресу ,.,Дев-сервер анализирует адрес запроса, получает путь до модуля, и какой файл запрошен, выполняет сборку запрошенного бандла, кэширует результат и отправляет в браузер. При изменении файла кэш сбрасывается, а браузеру отправляется команда перезагрузить вкладку, после чего файл запрашивается снова и происходит его сборка.,Дев-сервер собирает только те файлы, которые непосредственно запрашиваются из браузера, для того чтобы собрать все артефакты, необходимо запустить сборку вручную.,Сейчас дев-сервер поддерживает сборку только веб-приложений. Если вы разрабатываете NodeJS проект, то вы можете запустить дев-сервер и вручную отправлять запрос за файлом ,, для его пересборки.,MAM автоматически отслеживает зависимости между модулями, анализируя FQN-имена  в исходниках. Если мы хотим ""экспортировать"", какую-то сущность из модуля, чтобы она была доступна в других модулях, необходимо дать ей имя в формате FQN. Чтобы использовать метод, функцию или любую сущность из другого модуля, нужно просто написать ее имя.,Например, в модуле , объявлено две функции,Ими можно воспользоваться в любом другом модуле, просто написав имя ,, будто она объявлена выше в этом же файле.,Обратите внимание, что совпадать должен только префикс имени , с путем до файла ,. В этом же файле мы можем объявить функцию с таким именем ,, это не значит что мы обязаны класть эту функцию в ,.,Теперь давайте воспользуемся FQN-именами в нашем приложении и заодно разобьем его на несколько модулей.,Получится такая структура:,Переименуйте класс , в  ,, создайте файл , и перенесите туда код этого класса.,Тоже самое делаем с классом ,И с классом ,В файле , остался класс ,. Измените его имя на , и имена переименованных классов.,Запустите дев-сервер, если еще не сделали этого, и убедитесь что приложение  работает.,Положите ссылку на него в переменную с более коротким именем.,Станет:,Сборка работает по нескольким правилам:,. Анализируется по FQN-именам., и ,, а также копируются статические файлы командой ,. Подробнее рассматривается ниже.,. Например, при сборке модуля ,, в бандлы будут включены модули ,, ,, ,, ,. Код родительского модуля, будет включен раньше кода модуля. Как пример можно рассмотреть модуль ,, он находится непосредственно в репозитории с дев-окружением, и будет включен в дистрибутив при сборке любого модуля.,. Если модуль включается в дистрибутив, то все его файлы, с которыми умеет работать MAM, будут включены в соответствующие бандлы. Подмодули не включаются автоматически, только если срабатывают правила выше.,Добавим модуль для работы с localStorage. Создайте директорию для модуля , и , файл.,Сейчас не нужно его использовать в ,.,Добавьте в файл , еще одну кнопку - ,. Она не будет использоваться, нужна только для демонстрации.,После сборки откройте бандл ,. Найдите класс ,, он включен в бандл, потому что модуль , используется в приложении, а класс минорной кнопки объявлен именно в нем. Если вынести объявление кнопки в отдельный модуль ,, тогда она не добавится в бандл.,Класс , вы не найдете в бандле, потому что он не используется в приложении.,Теперь используем модуль , в коде.,После сборки вы найдете модуль , в бандле.,Создайте модуль , с файлом ,Код выше, раз в 30 секунд меняет значение атрибута ,, на элементе ,.,Создайте , файл в модуле , знак , в FQN-именах не используется,Откройте приложение, вы увидите что цвет фона страницы, меняется каждые 30 секунд.,Сборщик находит имя модуля , в файле , и добавляет все файлы модуля , в бандлы. Найдите его код в бандле ,.,После добавления , файла, вы найдете несколько новых модулей в , бандле. Сейчас стили добавляются в , бандл с помощью функции ,. Она и ее зависимости добавлены в бандл.,Во время рефакторинга, может понадобится перенести модуль в другое место. Поскольку имена зависят от месторасположения, их тоже нужно менять. Вам нужно выполнить команду редактора ,. Например, ищем все имена с именем , и заменяем на ,, после перемещения файлов.,, их придется менять отдельно,Вынесем в отдельный модуль, модули с библиотечным кодом ,, , и т.д., а в модуле , останется только код приложения.,Создайте директорию для модуля ,Переместите директорию  , в ,, и используя , переименуйте все строки , в ,. Поиск и замена производится на уровне корневой директории ,.,Повторите проделанное выше с остальными модулями: ,, ,, ,, ,.,Сейчас весь библиотечный код находится в модуле ,, а в модуле , остался только прикладной код. Убедитесь что приложение работает.,MAM поддерживает работу с обоими типами репозиториев одновременно. Их можно вкладывать друг в друга, также как и модули. Сборщик автоматически клонирует отсутствующие репозитории. Можно произвольный модуль вынести в отдельный репозиторий, без изменения его исходного кода. Разработчик использует одно дев-окружение, в котором находятся все проекты рядом, каждый в своем неймспейсе/модуле, в том числе неймспейс ,. Т.е. при разработке это выглядит как один большой монорепозиторий, можно внести изменения в любой модуль, но при этом этот код может хранится во множестве удаленных репозиториях на github, gitlab, bitbucket и т.д.,Для того чтобы сборщик мог загрузить репозиторий, он должен знать его адрес. Ссылки на удаленные репозитории находятся в файле ,, который размещается в родительском модуле, по отношению к модулю который выносится в удаленный репозиторий. ,Команда выглядит так:, , - инструкция, говорит сборщику что перед нами удаленный репозиторий, - имя директории подмодуля, в которую будет загружен репозиторий, - система контроля версия, сейчас поддерживается только одна.,после , размещается ссылка на репозиторий.,Разберем на примере как это работает:,Запускаем команду ,.,Сборщик не найдя директорию ,, ищет , в директории ,В , находит строку в которой директория подмодуля называется , -  ,Клонирует этот репозиторий в ,Ищет директорию ,, не найдя заглядывает в ,, теперь его интересует строка начинающаяся с ,. Найдя ее, клонирует репозиторий в ,.,Приступает к сборке ,Для того, чтобы VSCode корректно работал с несколькими репозиториями, создайте файл , с подобным содержимым:,На вкладке контроля версий, у вас появится несколько репозиториев.,Сейчас мы вынесем неймспейс , и модули ,, , в отдельные репозитории.,Создайте репозиторий с именем , на ,Создайте git-репозиторий в модуле , и свяжите его с репозиторием созданным на github. , замените на свое значение,Повторяем шаги 1 и 2 для модулей , и ,. Репозитории назовите , и , соответственно.,Создайте файл  , с таким содержимым:,Отправьте коммит с ним в удаленный репозиторий,Удалите директории модулей , и ,, и запустите сборку модуля , - ,. Сборщик загрузит репозитории и соберет модуль. В логе вы увидите следующее:,MAM поддерживает две платформы - браузер и NodeJS. Файлы кода с тегом , будут включены только в , бандл, а с тегом , только в ,. Код без тега платформы попадет в оба бандла.,Ранее, мы добавили костыль ,, для того чтобы не падали тесты под NodeJS. Теперь исправим его.,Но сначала займемся небольшим рефакторингом, добавьте два статических метода в класс ,.,Мы переместили метод , и добавили метод ,, который поможет указать какой компонент является корневым., Удалите метод , и его вызов из класса , и добавьте присвоение компонента методу ,.,Создайте файла , в модуле ,.,Этот код будет добавлен только в , бандл. Метод , вызывается асинхронно, потому что в бандле , находится выше, чем , и установка значения происходит после запуска этого кода. Соберите модуль , вручную и проверьте что этот код присутствует в , бандле и отсутcтвует в бандле ,.,Для использования NPM пакетов и модулей с которыми поставляется NodeJS создан специальный модуль ,. Вы просто пишите , или ,. Сборщик MAM автоматически установит эти пакеты их typescript типы, добавит их в бандл ,.,Сейчас мы добавим изоморфности в наше приложение. Создайте директорию для модуля , и файл ,.,В общем коде для , и ,, мы просто объявили переменную, которой будет присвоено различное значение в зависимости от платформы. Создайте файл ,.,В , мы присваиваем этой переменной объект ,. Создайте файл ,.,В , мы присваиваем этой переменной экземпляр класса ,, с помощью него наш код сможет работать под NodeJS. Для , такого решения не достаточно, но для тестов вполне., потому что , не реализует все браузерное , и его типы с , не сходятся.,Замените прямые обращения к ,, на использование ,:,Запустите сборку вручную ,. Если директория , не содержит ,, вы увидите в терминале подобные сообщения:,В файл , добавятся зависимости:,Модуль , имеет зависимость от модуля, который использует NPM-пакет ,, поэтому он тоже добавился в ,., используется, потому что MAM использует модель , с NPM тоже. В экстренном случае, можно в директории модуля создать , и зафиксировать версию пакета в нем.,Файл , содержит typescript типы для всех модулей NPM и NodeJS.,Для этого в , предусмотрена команда ,. Нужно его создать и добавить строку  ,. При сборке файл будет скопирован в ,.  ,.,Давайте добавим fav-иконку к нашему приложению. Создайте модуль , и скачайте туда , иконку.,В модуле ,, создайте файл ,:,Соберите модуль ,, после сборки, вы найдете иконку по пути ,.,В , добавьте строку , внутри тега ,.,Сборщик автоматически включает в дистрибутив модули от которых зависит собираемый модуль. Иногда вам нужно добавить модули, от которых ваш код не зависит. ,, когда вы создаете приложение с каталогом компонентов. Для этого используются две команды , и ,, которые добавляются в файл ,. Если необходимо подключить код указанного в команде модуля, раньше кода модуля в котором находится ,, то используйте , иначе используйте ,.,Создайте директорию для модуля , и внутри файл ,, с таким содержимым:,Соберите модуль , и проверьте , бандл. Все подключенные модули будут добавлены в него.,Теперь настроим автопубликацию модуля , в NPM. Для начала создайте аккаунт или войдите.,Откройте бандл , и проверьте поле ,. Имя генерируется автоматически, несколько человек не смогут опубликовать модуль, если проходя это руководство используют имя , для неймспейса. Создайте файл , в модуле , с другим именем.,Поля из добавленного , будут объедены с полями сгенерированного ,. Если вы сейчас соберете модуль, то увидите что бандле имя изменилось.,Убедимся что имя свободно.,Если занято, измените его.,Создайте персональный токен доступа для NPM.,Создайте секрет в репозитории , с именем , и созданным токеном в качестве значения.,Создайте файл ,:,Отправьте изменения на гитхаб и через несколько минут, пакет будет опубликован в NPM.,При использовании NPM-пакетов, мы просто экспортируем их имена из нужного бандла , или ,.,Чтобы NPM-пакет работал в браузере, его код необходимо добавить в бандл ,.,На данный момент MAM сборщик самостоятельно обрабатывает код NPM-пакетов, т.к. он не заточен под NPM, это приводит к некоторым проблемам. Например не умеет удалять неиспользуемые ветки кода - ,. Так же у MAM нет необходимости в ,, т.к. он сразу подключает только используемые модули, но NPM-пакетам он нужен. В будущем код NPM-пакетов, будет обрабатываться отдельным бандлером, таким как , и т.п.,В общем виде процесс подключения NPM-пакета выглядит так:,создать модуль для этого пакета,в модуле импортировать пакеты и типы через ,положить все сущности которые надо экспортировать из пакета в переменные с FQN-именами,Простой , подключения ,. Код модуля может быть сложнее простого реэкспорта. Например там может быть какой-нибудь адаптер, или демо с примером использования модуля.,Для NPM-пакетов создан отдельный модуль ,, ,. При добавлении какого-то пакета, лучше добавлять его сразу туда.,Сейчас мы не будем будем использовать написанное ранее приложение, а добавим модуль подключающий , в MAM. Он уже добавлен ,. Для практики, вы можете самостоятельно добавить другой пакет по примеру ниже.,Для начала нужно загрузить репозиторий модуля ,, запустите ,. Загрузить его можно и через ,, но ссылка на репозиторий уже находится в ,, сборщик сам загрузит его по ней.,Создайте директорию для модуля , и , файл в ней., - они используются в системе инверсии контроля ,, как средство авторегистрации сущностей в контейнере, об этом мы поговорим в другой главе.,Мы просто импортировали , и положили его в ,. В , вынесена функция ,, она будет использоваться как короткая ссылка для указания какую функцию использовать при транспиляции ,.,Создадим модуль для , - ,В модуль , положим приложение счетчик, для иллюстрации работы с модулем ,.,Попробуйте открыть демо-приложение. Запустите дев-сервер и откройте в файловом менеджере ,. Вы увидите ошибку.,Сборщик не умеет вырезать такие куски кода, пока что обойдемся заглушкой. Создадим для этого модуль ,.,Используем ,, чтобы без дополнительного кода объявить переменную на глобальном объекте. , тут не нужен, т.к. тогда typescript завернет этот код в вызов функции.,Нам нужно, чтобы этот код был включен в бандл и выполнен раньше, чем код ,. Создадим файл ,Код из модуля ,, будет подключен в начало банла, перед кодом ReactJS.,Обновите страницу, приложение должно заработать. Этот адаптер нуждается в доработке, но для начала годится.,Для этого нужно создайте файл , в модуле, который вынесен в отдельный репозиторий.,После отправки коммита, приложение будет задеплоено. Исходники github action ,.,Сейчас настроим деплой нашего приложения на github. Сначала создайте персональный токен доступа ,. Создайте секрет в настройках репозитория ,, с созданным токеном, назовите его GH_PAT.,Создайте файл  ,, не забудьте заменить , в ссылке на репозиторий ,.,Параметры, которые принимает github action описаны в ,. Параметр , содержит ссылку на репозиторий неймспейса ,, т.к. у него в файле , указана ссылка на репозиторий модуля ,, который нужен для сборки приложения. Если его не указывать, то сборка завершится ошибкой - не найден модуль  ``$my_lom`.,После отправки изменений на github, начнется сборка, после ее окончания, вы найдете ссылку на приложение тут: ,., Скопируйте ее в описание репозитория.,Сборщик оценивает жесткость зависимостей, чем она сильнее тем раньше модуль будет включен в бандл. Жесткость оценивается по простой эвристике - количеству отступов в строке, в которой находится зависимость.,Для демонстрации циклической зависимости, мы создадим несколько файлов с кодом вне директории MAM и запустим их с помощью NodeJS.,Создайте где-нибудь директорию , и файл ,Запустите его , - ошибок нет. В нем есть циклическая зависимость, но код работает корректно. Разделим его на несколько файлов.,Запустите ,, вы увидите ошибку ,. Для ее исправления, нужно добавить импорт , перед ,.,Теперь перенесем этот код в MAM. Создайте модули ,, ,, , с соответствующим содержимым.,Соберите модуль , и посмотрите код в , бандле.,Сборщик склеивает файлы в таком порядке, как будто мы изначально писали код в одном файле. Зависимость , от , сильнее чем , от ,, поэтому модули добавляются в бандл в таком порядке: ,, ,, ,.,Создайте корневой нейспейс - вам нужен модуль, который будет содержать все ваши наработки. Разместите его в отдельном репозиторий.,Если планируется распространять ваш код по открытой лицензии, то добавьте ссылку на него в , через pull-request.,В рамках вашего неймспейса создаются неймспейсы для публичных и приватных модулей, которые разносятся по разным репозиториям.,Модули группируются по функциональности, а не по типу. Не должно быть директорий-складов ,, ,, ,, ,, , и т.п. Модуль должен представлять из себя домен, который хорошо решает свою задачу. Например ""хелпер"" для сравнения объектов, можно отправить в модуль , или сразу вынести в подмодуль , и использовать его на всех проектах.,Вся важная функциональность должна покрываться тестами.,При замораживании разработки репозиторий дев-окружения форкается и ревизии фиксируются через git-merge-tree, а также обновляется пайплайн на использование форка.,В следующей части мы научимся работать с системой реактивности $mol, - с вопросами, проблемами, предложеними пишите в наш чат. Вступайте, если следите за проектом., - новости об экосистеме фреймворка $mol.,Пользователь",Введение в $mol. Часть 1. Модульная система / Хабр
[<200 https://habr.com/ru/post/662682/>],page2,"Несмотря на бурное развитие технологий, по сегодняшний день многие разработчики гнушаются локальным хранением элементарной информации: используют Google fonts, загружают килобайтный JS-файл с сервера, расположенного на другом континенте и прочие топологические и логические ,. При таком подходе к разработке веб-приложений мысли о локально-генерируемой и этичной капче появляются крайне редко. А если и появляются, возникают вопросы: как генерировать, хранить и проверять ответы, ассоциировать картинки с конкретной сессией пользователя и прочее. Итог почти всегда один: использовать сторонние онлайн-сервисы вроде reCAPTCHA. На вкус и цвет товарищи всегда найдутся, но сейчас рассмотрим альтернативу.,Давайте познакомимся с Zero Storage Captcha, которая работает локально (возможно, в виде дополнительного класса в коде приложения), не обязывает хранить информацию на стороне сервера о сгенерированных картинках и в тот же момент позволяет проверить ответ любого пользователя со стопроцентной вероятностью.,Если не хочется организовывать базу данных под капчи, почему бы не хранить ответ на капчу у самого пользователя? Чтобы реализовать эту идею и при этом исключить перехват ответа на картинку на стороне пользователя, нужно обратиться к базовой криптографии. Пусть пользователь хранит не ответ в чистом виде, а специальный токен, который будет передан серверу вместе с ответом на капчу и позволит проверить правильность ответа. Криптография поможет нам не хранить пару ""правильный ответ - токен"", а производить проверку через простые вычисления по факту поступления запроса от пользователя.,Встает несколько вопросов:,Алгоритм генерации токена, защищенный от подделки;,Ограничение времени жизни капчи;,Невозможность использования одного верного ответа дважды.,Опустим детали того как генерируется изображение. В эталонной реализации отрисовка происходит графическими силами фреймворка Qt/C++, но это не принципиально и вполне возможны другие решения.,Итак, при получении капчи, которую пользователю следует разгадать, он получает изображение и проверочный токен. Затем на сервер отправляются ответ пользователя и тот самый токен, благодаря которому происходит проверка правильности введенных данных.,Токен базируется на следующих составляющих:,Верный ответ на капчу;,Хеш (SHA256);,Подпись (X25519);,Временной маркер.,В виде формулы алгоритм создания токена можно представить так:,Фактически токен является подписью в кодировке base64. Чтобы сделать токен более компактным, принято решение сокращать подпись в три раза — в итоговую строку добавляется каждый третий символ. Также удаляются все спецсимволы вроде ,, , и ,. На выходе получается строка примерно такого вида: ,.,Временной маркер (time token) обновляется каждые полторы минуты, благодаря чему через небольшой промежуток времени проверочный токен для капчи с тем же ответом будет абсолютно новый.,Логика построена таким образом, чтобы одновременно хранились два тайм-токена: актуальный и предыдущий. Это необходимо для нормальной проверки капчи, которая была сгенерирована за несколько секунд до смены тайм-токена. Если проверка ответа с актуальным тайм-токеном выдает ,, происходит проверка с предыдущим. Учитывая эту специфику, несложно подсчитать примерное время жизни сгенерированной капчи: от полутора до трех минут.,Фактором уникальности проверочных токенов также является сессионный ключ подписи, который генерируется при каждом запуске приложения (вернее, при первом обращении к классу, отвечающему за генерацию капчи).,Можно усомниться в нужности хеша, так как операция подписи даст не менее уникальную строку при прямом применении к сконкатенированной строке ,. С этим сложно поспорить, поэтому оправдывать хеш сильно не стану: в изначальной реализации он есть и хлеб не просит. Возможно, в будущих реализация Zero Storage Captcha произойдет отказ от предварительного хеширования.,Получая от пользователя токен и ответ на капчу, сервер выводит из ответа пользователя новый токен. Если новый токен и изначальный проверочный совпадают, о верности ответа выносится положительный вердикт. ,Чтобы верным ответом нельзя было воспользоваться более одного раза, после успешного прохождения проверки проверочный токен заносится в специальный кеш, где хранится в течение короткого жизненного цикла капчи (до трех минут). Если на проверку поступит токен, имеющийся в кеше использованных токенов, ответ сервера будет отрицательным.,Сфера применения описанной технологии также широка, как и область применения любой капчи. В сценарии с веб-страницами Zero Storage Captcha может быть реализована при помощи JS, либо силами чистого HTML, если он генерируется на бекэнде и позволяет подставлять дополнительный уникальный ключ в , отправки ответа на капчу.,Если вы хотите использовать Zero Storage Captcha в проектах на C++, ознакомьтесь с , на несколько сотен строк. Если интеграция плюс,вого класса в ваш продукт затруднительна, воспользуйтесь Zero Storage Captcha в виде отдельного ,, которое предоставляет простой REST API и может работать как локально, так и на любом удобном для вас сервере.,Энтузиаст отказоустойчивых и скрытых сетей",Самодостаточная капча без бутстрапа и БД / Хабр
[<200 https://habr.com/ru/company/htmlacademy/blog/661297/>],page2,"Дайджест новостей из мира фронтенд-разработки за последнюю неделю 18–24 апреля., — стандарт, описывающий безопасный низкоуровневый код, , — стандарт взаимодействия API JavaScript с WebAssembly и , — стандарт интеграции WebAssembly с остальной веб-платформой., ,.,.,. 16px уже мало.,Узнайте про соотношение цвет текста к цвету фона и ,., для создания интерфейса.,., Это позволит разработчикам не траспилировать TS, Flow и другие надмножества с статической типизацией.,Делайте ,Просто узнайте, что будет в ,, но Current. Не переживайте, так как переход на LTS планируется уже в октябре. Новинки: V8 10.1, Fetch на базе Undici.,Начиная с v18.0.0 пишите ,., ,, изоморфный HOC «видимости страницы», v7.0, v4.0.0, в Google Chrome 101,В дайджесте много статей и видео на английском языке, чтобы это не стало препятствием: в Google Chrome есть функция перевода страницы с любого популярного языка, а видео можно перевести в Яндекс Браузере.,Автор профессиональных курсов","Фронтенд-новости №3. Node.js v18.0.0, аннотации типов в JavaScript, СSS Toggles / Хабр"
[<200 https://habr.com/ru/post/662708/>],page2," — это один из компонентов, где обычно происходит утечка памяти, поскольку именно он чаще всего используется для хранения множества частей кода вместе. Одна ошибка, и в итоге вы получаете утечку., предлагает отличный инструмент для отладки утечек памяти. Часто для этого используется метод , в  ,.,Если произошла утечка, , не будет вызван, и ничего не будет выведено. Даже если это не очень хорошо выглядит, это вполне рабочий вариант.,Если вы найдёте статью интересной, то , я пишу об iOS-разработке.,Можно использовать ,, чтобы обнаружить retain cycles для UIViewController. Это та же концепция, что print выше, но гораздо чище. Таким образом, вы не накидываете в код лишние ,.,Перейдите в , (меню ,). Кстати, для шорткатов можно использовать и это решение: ,. , Нажмите , и выберите Symbolic Breakpoint... or ,Установите для , значение ,Нажмите  кнопку , и установите звук , в (ну или любой другой, какой посчитаете нужным).,Добавьте ещё одно действие, нажав ,.,Установите действие на , и задайте сообщение, которое вы хотите вывести в консоль, когда сработает dealloc для View Controller. В моем случае я установил его в ,Отметьте опцию ,s, поскольку мы не хотим, чтобы дебаггер останавливался, когда сработает наш Symbolic Breakpoint.,С установленным брейкпоинтом всякий раз, когда для UIViewController сработает ,, или, например, , из навигационного стека, вы услышите соответствующий звук и увидите лог в консоли. Это означает, что все работает именно так, как ожидалось.,Если вы выводите или удаляете ,, но не слышите соответствующего звука, это означает только одно — произошла утечка., — , — пустой или , — , или любой другой звук, — , или любое другое сообщение,—,можно установить,Если вы нашли что-то полезное для себя, то подписывайтесь на мой канал, ,.,Мобильный разработчик",Простой способ обнаружить retain cycle в UIViewController / Хабр
[<200 https://habr.com/ru/company/piter/blog/662662/>],page2,"В декабре 2021 года Github объявил, что открывает общий доступ к , для всех публичных и приватных репозиториев с Python на сайте GitHub.com. Точную навигацию в коде обеспечивают ,, новый фреймвввооорк с открытым исходным кодом, созданный в Github и позволяющий устанавливать правила привязки имен для языка программирования при помощи декларативного предметно-ориентированного языка (DSL). Стековые графы позволяют генерировать данные о навигации по стеку для конкретного репозитория, , при этом какого-либо участия в конфигурировании со стороны владельца репозитория и , вмешиваясь в процесс сборки или другие задания, связанные с непрерывной интеграцией. В этом посте будет подробно рассказано, как работают стековые графы, и как с их помощью достигаются такие результаты.,Навигация в коде – это совокупность возможностей, позволяющих на глубоком уровне исследовать существующие в вашем коде взаимосвязи и зависимости. Простейшие варианты навигации в коде – это «перейти к определению» и «найти все ссылки». Обе основаны на том факте, что код, который мы пишем, всюду нашпигован ,. Языки программирования позволяют давать , сущностям – функциям, классам, модулям, методам, переменным и пр. У всех этих сущностей есть имена, поэтому на них можно , из других частей нашего кода.,Иллюстрация (даже простая) стоит тысячи слов:,В этом модуле Python ссылка на , в конце файла указывает на определение функции, сделанное ранее в этом же файле (в рамках этого поста я буду подсвечивать определения красным, а ссылки синим.),Таким образом, наша цель – собрать информацию о списках определений и ссылок и иметь возможность установить, какие определения с какими ссылками соотносятся, и так для , кода, расположенного на GitHub.,В вышеприведенном примере определения и ссылки располагались близко друг к другу, и не составляло труда наглядно представить отношения между ними. Но так просто бывает не всегда!,Что делать, например, если у нас множество одноименных определений? В Python имена могут , друг друга, и это значит, что ссылка , должна относиться ко , из этих двух определений.,Но эти правила специфичны для каждого языка! В Rust не разрешено, чтобы определения верхнего уровня затеняли друг друга, а для переменных это разрешено. То есть, если транслитерировать этот мой пример с Python на Rust, то, в соответствии со спецификацией языка Rust, в коде будет ошибка. Если бы мы писали компилятор для Rust, то хотели бы, чтобы эта ошибка быстро проявлялась, и программист ее исправлял. А что насчет исследовательской фичи, такой как навигация кода? Мы хотим увидеть какой-либо результат, даже в случае, когда код содержит ошибки. В конце концов, человеку свойственно ошибаться! ,До сих пор мы рассматривали лишь примеры, состоящие из единственного файла каждый. Но когда вы в последний раз работали над программным проектом, в котором всего один файл? Гораздо вероятнее, что ваш код будет разбросан по множеству файлов, множеству пакетов, множеству репозиториев. Языки программирования позволяют ссылаться на определения, которые находятся очень далеко от самой ссылки. Но, как и следует ожидать, правила ссылок на сущности в других файлах отличаются от языка к языку.,В вышеприведенном примере я разделил весь код на три файла, которые находятся в двух отдельных пакетах (репозиториях). Вместо имен пакетов я поставил смайлики. В Python инструкции , позволяют ссылаться на имена, определенные в других модулях, а имя модуля определяется именем того файла, в котором содержится его код. В сумме это показывает нам, что ссылка , из файла , в пакете “chef” указывает на определение , в файле , в пакете “frying pan”.,Со временем код меняется и развивается. Что произойдет, когда одна из ваших зависимостей изменит реализацию вызываемой вами функции? В таком случае люди, отвечающие за поддержку пакета “frying pan” добавляют к функции , кое-какие возможности логирования. В результате ссылка , в файле , теперь указывает на иное определение. Особенно коварно то, что в данном случае изменился промежуточный файл, а не тот, в котором содержалась ссылка, и не тот, в котором содержалось исходное определение! Если бы мы были неаккуратны, то нам пришлось бы заново проанализировать , файл в репозитории ,, и так каждый раз, как только изменится любой файл! Таким образом, работа, которую нам приходится проделать, возрастает по мере изменения файлов квадратично, а не линейно, а при таких масштабах как в GitHub это тем более серьезная проблема.,Наша последняя трудность связана именно с масштабом. Как упоминалось выше, мы хотим предоставить описанную возможность для , кода, расположенного на GitHub. Более того, мы хотим добиться, чтобы ни от кого из владельцев репозиториев не требовалось дополнительно вносить какую-либо конфигурацию вручную. Не следует требовать от вас, чтобы вы сами выясняли, как получить данные для навигации по коду вашего языка и проекта, либо как настроить непрерывной интеграции, чтобы сгенерировать эти данные. Навигация по коду должна Просто Работать.,В масштабе GitHub здесь возникает две проблемы. Первая – чистый объем кода, поступающий на сайт каждую минуту и каждый день. В каждом коммите, который мы получаем, следует ожидать, что изменения внесены лишь в очень немногочисленные файлы из всех имеющихся. Мы , быть в состоянии полагаться на ,, повторно используя результаты, ранее уже вычисленные и сохраненные для тех файлов, которые на данном этапе не изменились.,Второй вызов, стоящий перед нами – огромное количество языков программирования, которое нам (в конечном итоге) придется поддерживать. На GitHub хранится код на любых мыслимых языках программирования. Git как таковой не волнует, какой именно язык вы используете в вашем проекте, для Git все состоит из одних байт. Но при реализации такой возможности как навигация в коде, при которой правила привязки имен отличаются для каждого языка, необходимо знать, как разбирать и интерпретировать , этих файлов. Чтобы поддерживать эту возможность в большом масштабе, требуется максимально упростить как инженерам GitHub, так и сторонним языковым сообществам описывать правила привязки имен для языка.,Подытожим:,В разных языках действуют разные правила привязки имен.,Некоторые из этих правил могут быть весьма сложными.,Результаты могут зависеть от промежуточных файлов.,Мы не хотим, чтобы требовалось вручную конфигурировать каждый репозиторий.,Для работы в масштабе Github требуется инкрементная обработка.,Изучив круг проблем, мы решили создать стековые графы, помогающие ответить на эти вызовы. За основу мы взяли фреймворк ,, разработанный исследовательской группой , из ,. Ниже будет рассмотрено, что такое стековые графы, и как они работают.,Поскольку нам приходится полагаться на инкрементные результаты, важно, чтобы во , (то есть, пока мы получаем пакеты с новыми коммитами), можно было ,. Наша цель – извлечь «факты» о каждом файле, описывающие определения и ссылки из этого файла, а также все возможные сущности, в которые может разрешаться каждая из ссылок.,Рассмотрим следующий пример:,В нашем конечном результате должна быть предусмотрена возможность закодировать такой факт: ссылка на , и соответствующее определение находятся в разных файлах. Но, чтобы анализ был инкрементным, нужно рассмотреть каждый файл в отдельности. Я зайду в каждый из файлов и покажу, какую информацию GitHub может извлечь, рассматривая его в отдельности. ,Взглянув сначала на ,, видим, что в нем содержится определение ,. Из имени файла становится понятно, что это определение находится в модуле ,, и, следовательно,  , будет ,. Этот факт можно представить, создав структуру в виде графа (и в этом графе также можно поместить другие символы, содержащиеся в файле). Каждое определение (включая сам модуль) получает красный узел в двойной рамке – он называется ,. Другие узлы, а также паттерн, в соответствии с которым мы соединяем эти узлы ребрами, устанавливают области видимости и правила затенения для этих символов. Мы не станем внедрять в других языках программирования такие же правила затенения как в Python, поэтому получится другим и паттерн расположения ребер, соединяющих все сущности.,То же самое можно проделать с файлом ,. Ссылка , представлена в виде , – он синий, с одиночной границей. В графе также присутствует конструкция ,, как характерная деталь узлов, затрагивающих при работе символы , и ,.,Поскольку мы рассматриваем этот файл в отдельности, мы пока еще не знаем, во что разрешается ссылка ,. Здесь , означает, что она , разрешаться в ,, определенный в каком-то другом файле — но это зависит от того, а , файл, определяющий этот символ. На самом деле, в данном примере такой файл содержится (мы его только что рассматривали!), но это необходимо игнорировать, выясняя факты о , один за другим.,Однако, во , мы в силах объединить данные из всех файлов того коммита, который сейчас рассматриваем. Можем загрузить графы по каждому из файлов, получив единый «консолидированный» граф для целого коммита:,Внутри такого консолидированного графа каждая действительная привязка имен представлена путем от узла ссылки до узла определения.,Тем не менее, не каждый путь в графе соответствует действительной привязке имени! Например, если рассмотреть только структуру графа, есть совершенно нормальные пути от ссылочного узла , до узлов с определениями , и ,. Чтобы исключить эти пути, мы при поиске путей также должны поддерживать ,. Каждый синий узел забрасывает символ в стек, а каждый красный узел выталкивает символ из стека. Важно, что нам , перейти к “выталкивающему” узлу, если его символ не совпадает с символом, расположенным на вершине стека.,В паре мест на том пути, что подсвечен выше, мы показываем содержимое символьного стека. Самое важное, что, когда мы доходим до той части графа, где содержатся узлы определений ,, , и ,, символьный стек содержит ,, гарантируя, что только , путь из всех обнаруженных нами окончится на определении ,.,Также можно использовать различные структуры графов, чтобы обработать другие мои примеры. А именно: ,В этом графе мы аннотируем некоторые из ребер, присваивая им значение ,. Пути, в которых содержатся ребра с более высоким значением приоритета, предпочтительны по сравнению с теми, в которых значения приоритета ниже. Это позволяет нам правильно обработать поведение затенения, предусмотренное в Python.,Что касается других языков программирования, не реализующих такое же поведение затенения как Python, сущности будут соединяться ребрами в соответствии с иным паттерном. Например, вот как выглядел бы стековый граф для моего более раннего примера на Rust:,Для того, чтобы смоделировать правило Rust, в соответствии с которым одноименные определения высшего уровня приводят к конфликту, у нас есть всего один узел, с которого свешиваются все определения. При помощи значений приоритета можно выбрать, показать ли все конфликтующие определения (присвоив им всем одинаковые значения приоритета), либо только первое (присваивая значения приоритета последовательно).,Имея стековый граф, можно реализовать возможность «перейти к определению»: ,Пользователь щелкает по ссылке.,Мы загружаем стековые графы для каждого из файлов в коммите и консолидируем их.,Выполняем поиск пути, начиная со ссылочного узла, соответствующего тому символу, по которому щелкнул пользователь, учитывая при этом символьные стеки и значения приоритета – так гарантируется, что мы не создадим никаких недействительных путей.  ,Все действительные пути, которые мы найдем, ведут к определениям, на которые указывает ссылка. Их мы отобразим во всплывающей подсказке.,Я описал, как , стековые графы для выполнения навигации в коде, но еще не упомянул, как их создавать из исходного кода, который вы загружаете на GitHub.,Для этого обратимся к , свободному фреймворку для синтаксического разбора (парсинга) кода. Сообщество Tree-sitter уже написало парсеры для , языков программирования, и мы уже используем Tree-sitter во многих частях GitHub. Поэтому естественно выбрать этот фреймворк для построения стековых графов на его основе. ,Парсеры Tree-sitter уже позволяют нам эффективно , код, загружаемый нашими пользователями. Например, парсер Tree-sitter для Python строит , (CST) для файла ,:,Tree-sitter также предоставляет язык запросов, позволяющий нам отыскивать паттерны внутри CST:,Этот запрос нашел бы все три определения методов из нашего примера, аннотировав каждое определение в целом при помощи метки ,, а имя каждого метода при помощи метки ,.,В рамках разработки стековых графов мы добавили в Tree-sitter новый ,, на котором можно собирать произвольные графоподобные структуры (в том числе и стековые графы – но не только) из разобранных конкретных синтаксических деревьев. Существуют ,, то есть, строки, определяющие конкретные признаки тех узлов и ребер графа, которые должны создаваться на основании каждого найденного запроса Tree-sitter и определяющие, как новоиспеченные узлы и ребра должны присоединяться к уже имеющейся структуре графа. Например, следующий фрагмент кода создаст узел с определением стекового графа для моего примера с определениями методов на Python:,При помощи такого подхода можно инкрементно создавать стековые графы для каждого файла исходников, который мы получаем. При этом нам приходится анализировать только содержимое исходников, не прибегая к какому-либо инструментарию, специфичному для языка, либо к системам сборки. (Единственная языково-специфичная деталь здесь – это набор правил построения графов для конкретного языка!) ,Этот пост уже получился достаточно длинным, а мы лишь слегка копнули тему. Возможно, у вас возникли такие вопросы:,Выполнение полноценного поиска пути при каждом запросе «перейти к определению» кажется расточительным. Можем ли мы предварительно рассчитать больше информации за время индексирования, не жертвуя при этом инкрементностью? ,Все приведенные примеры очень тривиальны. Позволяет ли такой метод справиться с более сложными примерами? ,Что, например, делать со следующим файлом на Python, где приходится использовать ,, чтобы отследить, какое именно значение было передано , в качестве параметра и, соответственно, корректно разрешить ссылку в , в последней строке?,Либо следующий файл на Java, где нам требуется отследить наследование и параметры обобщенных типов, чтобы посмотреть, должна ли ссылка на , разрешаться в , из стандартной библиотеки Java?,Почему мы не используем , (LSP) или , (LSIF)?,Чтобы подробнее разобраться со всем этим, рекомендую вам послушать мою лекцию на , и посмотреть контейнер ,: нашу свободную реализацию этих идей, написанную на Rust. Тем временем – осваивайте навигацию! ,Пользователь",Знакомство со стековыми графами / Хабр
[<200 https://habr.com/ru/post/662694/>],page2,"В феврале прошлого года я впервые обращался к теме прогнозирования новых химических соединений методами глубокого обучения — когда опубликовал ,. Такие исследования, находящиеся на стыке физики, химии, биоинформатики и фармакологии, призваны смоделировать потенциально возможные химические связи и конфигурации молекул. Так можно одновременно удешевить и значительно ускорить разработку новых лекарств. Также я затрагивал эту тему в ,, но в несколько ином аспекте: гравитация вносит коррективы в форму молекул, поэтому некоторые конфигурации молекул быстро «сминаются». Эта проблема остро стоит при производстве баснословно дорогих препаратов (прежде всего, противораковых), терапевтический эффект которых заключается в поддержании строго определенной формы молекул, блокирующих патологические биохимические процессы. Если бы мы могли поставить на поток производство филигранных молекул (в частности, ферментов), блокирующих работу определенных белков, это преобразило фармакологию, в значительной степени ее персонализировав. Но у такой линии исследований есть и обратная сторона: она открывает путь к созданию чрезвычайно токсичных и цепких веществ, которые было бы практически невозможно «выковырять» из биохимического аппарата, если они там окажутся. ,Невозможно было бы сделать в этой статье даже краткий обзор машинного и глубокого обучения как предметной области, не отвлекаясь от темы. Поэтому я оговорюсь лишь о том, что машинное и глубокое обучение являются подразделами искусственного интеллекта и не идентичны друг другу. Машинное обучение можно сравнить с исключительно продвинутым статистическим анализом больших множеств данных; машинное обучение позволяет выявлять закономерности и находить решения именно по статистическим признакам и явно программировать компьютер (указывать ему пошаговую последовательность операций для достижения цели) при машинном обучении не требуется. При глубоком обучении компьютеры образуют (многослойную) нейронную сеть: на каждом из слоев этой сети обрабатываются признаки анализируемого множества данных, после чего вывод предыдущего слоя сети служит вводом для следующего. При этом применяются и методы машинного обучения, но методы глубокого обучения не сводятся к чистой статистике, а отличаются значительным разнообразием: например, при помощи глубокого обучения удобно обрабатывать данные, полученные методом ,.  Максимально популярный обзор машинного обучения , в блоге Вастрика, а более строгое, но вполне понятное изложение (в частности, о соотношении глубокого и машинного обучения, а также о видах нейронных сетей) , в работе Дмитрия Павленко. Там же есть иллюстрация с соотношением рассматриваемых здесь предметных областей:,В целом (особенно, учитывая работу с признаками, описанную в работе Павленко , и далее) я бы охарактеризовал машинное обучение как «неизвестное об известном», а глубокое обучение как (одновременно) «понятное о неизвестном» или «достоверное о неизвестном». Поэтому при проектировании новых молекул ученым требуется прежде всего глубокое обучение с тщательной отбраковкой неоптимальных вариантов. Глубокое обучение в рассматриваемой области идет на основе данных о химических свойствах, совместимости и геометрии молекул.,Открытие новых препаратов нацелено на поиск новых химических соединений с конкретными свойствами, как правило – терапевтическими. В последние годы эта область тесно смыкается с информатикой, поскольку опирается на приемы машинного обучения, ставшие в последнее время гораздо более доступными. Библиотеки машинного обучения, предназначенные для решения узкоспециальных задач, чаще всего реализуются на языке Python – и ниже в этой статье будут упомянуты некоторые из таких библиотек, предназначенных именно для фармацевтического моделирования. В настоящее время развивается концепция «точной медицины» (precision medicine), с которой связан специфический набор проблем. Можно считать, что история точной медицины начинается с американского мальчика , (Nicolas Volker), который в 2009 году (в возрасте около 2,5 лет) попал под наблюдение врачей в детской больнице штата Висконсин, а к 2011 году перенес около 160 операций. Мальчик страдал непрекращающимися воспалениями кишечника, природа которых оставалась невыясненной. Потребовалось полностью секвенировать его геном, чтобы найти редкую мутацию в гене XIAP, отвечающем за апоптоз (запрограммированную смерть клеток). Природа точной медицины такова, что лекарства для нее крайне сложно разрабатывать традиционными методами – через обширные когортные исследования.  , длится многие месяцы или годы и охватывает сотни и тысячи человек. В разработках точной медицины счет идет в лучшем случае на годы, а уровень персонализации настолько высок, что исследовать препарат можно только на самом пациенте, либо на небольшой группе людей, страдающих таким же заболеванием (например, генетическим или онкологическим). Поэтому в доклинических исследованиях как никогда важными становятся воспроизводимые и стандартизированные приемы моделирования молекул и их взаимодействий. Эта новая научная дисциплина, условно именуемая хеминформатикой (cheminformatics) сейчас переживает период «большого взрыва» и позволяет резко сократить стоимость и сроки открытия новых лекарственных веществ. Конечно, у нее есть свои ограничения, но массу других ограничений (в том числе, связанных с государственным регулированием) она снимает – поэтому темная сторона этих разработок пока игнорируется или недооценивается.  Но темные и труднопрогнозируемые стороны хеминформатики напрямую связаны с достоинствами и недостатками нейронных сетей.  ,В процессе открытия новых лекарств подходы машинного обучения могут , в следующих целях:,Прогнозировать структуру целевых препаратов,Идентифицировать и уточнять перспективные варианты,Исследовать биологическую активность новых лигандов,Проектировать модели, предсказывающие фармакокинетику и , веществ-кандидатов            ,В биохимических исследованиях применяются варианты машинного обучения (ML), которые можно условно разделить на ,: обучение с учителем (supervised learning), обучение без учителя (unsupervised learning) и последовательное обучение (sequential learning). Данные, используемые для машинного обучения, бывают размеченными и неразмеченными. Под спойлером – краткая характеристика трех этих видов обучения.,Для обучения с учителем нужен размеченный (тренировочный) набор данных – на котором модель и тренируется. Натренировавшись, модель может сама приступать к выдаче прогнозов и формулированию решений по мере получения новых данных. Из методов обучения с учителем в биохимических задачах применяется метод опорных векторов и искусственные нейронные сети (ANN), способные вычленять сложнейшие паттерны в больших датасетах.   ,Обучение без учителя позволяет выявить взаимосвязи или паттерны в неразмеченных данных. Модель учится сама по себе, наблюдая множество данных и ,.,Последовательное обучение позволяет агенту (это сущность, перед которой поставлена цель) учиться в интерактивной среде методом проб и ошибок, оценивая опыт взаимодействий с этой средой как положительный и отрицательный. Следовательно, последовательное обучение – это вариант обучения с подкреплением (reinforcement learning).,Применение компьютеров при разработке лекарств началось еще в 1970-е, задолго до распространения машинного обучения. Технология CADD (Computer-aided drug discovery) (CADD) уже позволяет значительно удешевить и ускорить разработку лекарств на основе наиболее перспективных веществ-кандидатов, причем, пока препарат еще существует «на кончике пера». Практически , создаются обширные базы данных с «фармацевтическими» молекулами, чьи структурные формулы затем подвергаются виртуальному скринингу. В CADD используется два основных подхода к проектированию молекул: 1) структурный и 2) на основе лигандов (ligand-based drug discovery, LBDD). Такое проектирование еще называется QSAR.  Метод на основе лигандов позволяет проверить, какие мелкие молекулы могут подсоединиться (фактически – пристыковаться) к крупной белковой молекуле. Такой подход легко поддается оптимизации и моделируется при помощи готовых библиотек на Python. Первичная оценка свойств препарата, также выполняемая виртуально, сокращенно именуется , («поиск количественных отношений структура-свойство»). QSAR позволяет отыскивать потенциально активные соединения. Несмотря на относительную легкость такого поиска, даже «виртуальные» молекулы должны подвергаться предварительной оценке по параметрам ADMET (всасывание, распределение, метаболизм, выделение, токсичность). Соответственно, такая работа позволяет собирать данные не только о потенциально лечебных, но и о токсичных молекулах.,Метод , позволяет виртуально опробовать варианты стыковки молекул и степень их химического сродства (аффинности). При докинге выбирается белок-мишень, к которому затем подбирается молекула-лиганд – как правило, встраиваемая в белок с целью блокирования его работы: ,Именно на материале молекулярного докинга накапливается тот датасет, на основании которого можно ускорять разработку молекул. Ниже будут рассмотрены две разработки: движок DeepBAR, созданный в MTI (Массачусетском технологическом институте) и библиотека ,, позволяющая моделировать молекулы.,Итак, препарат будет работать лишь при условии успешного прикрепления к белкам-мишеням в организме. Оценка такой «прилипчивости» - ключевое препятствие в процессе открытия и скрининга препаратов. Новые исследования в этом направлении идут на стыке химии и машинного обучения. ,В MIT была разработана новая технология DeepBAR, позволяющая быстро вычислять сродство к связыванию между препаратами-кандидатами их мишенями. Такое сродство определяется свободной энергией связывания – чем меньше эта величина, тем крепче связь. На практике низкая энергия связывания приводит к тому, что препарат «выигрывает» у других молекул, также пытающихся связаться с белком. Следовательно, свободная энергия связывания – прямой индикатор потенциальной эффективности препарата.   ,Методы для вычисления свободной энергии связывания относятся к двум основным категориям, и у каждой – свои недостатки. Методы одной категории позволяют вычислить эту энергию точно, на что тратится значительное время и вычислительные ресурсы. Методы второй категории не так ресурсозатратны, но и свободную энергию связывания вычисляют лишь приблизительно.,DeepBAR занимает в этом отношении золотую середину, поскольку вычисляет искомую величину точно, но выполняет для этого гораздо меньший объем вычислений, чем более ранние методы – поскольку большая часть работы выполняется не при самих вычислениях, а на предварительном этапе, в ходе машинного обучения.,Аббревиатура «BAR» в DeepBAR означает «Bennett acceptance ratio», «оценочная функция Бенетта» - это алгоритм, используемый в структурной химии уже не один десяток лет. Для работы по этому алгоритму, как правило, требуется знать энергию двух «крайних» состояний: 1) молекула препарата прочно связана с белком и 2) молекулы белка полностью диссоциированы в растворе, а также учитывать множество промежуточных состояний (например, различные степени промежуточного связывания). ,DeepBAR выстраивает цепочку этих промежуточных состояний, вычисляя оценочную функцию Бенетта при помощи нейронных сетей, точнее – ,. Такие модели позволяют создать для каждой конечной точки два референсных состояния – «связь есть» и «связи нет».,Такие глубокие генеративные модели во многом основаны на наработках компьютерного зрения – в том, что очерчивание промежуточных состояний происходит примерно по тому же принципу, что и консолидация фрагментов при синтезе изображений компьютером. Фактически, молекула воспринимается как картинка (точнее – скульптура, поскольку у молекулы важна пространственная ориентация), и на таких картинках модель может учиться распознавать как сами молекулы, так и варианты связывания молекул и препаратов.,Иным образом устроена библиотека ,, реализующая на языке Python технологию ,. SMILES позволяет выражать цепочки химических связей в виде строк, а далее преобразовывать эти строки в последовательности целых чисел. Далее нейронная сеть, изучающая последовательности SMILES, присваивает весовые коэффициенты последовательностям чисел, которые вычленяет из датасета SMILES – и, следовательно, прогнозирует вероятность образования и прочность разнообразных химических связей. Работа Pysmiles выглядит примерно так:,Существуют и другие специализированные библиотеки для подбора конфигураций молекул:, — библиотека на языке Java, прогнозирующая свойства материалов при помощи методов машинного обучения.  , — библиотека на языке Python для соотнесения химической структуры веществ с их свойствами , — библиотека на языках Python и С++ для биоинформатики и хеминформатики/,Наиболее заметной инициативой по оценке токсичности проектируемых препаратов был конкурс ,, состоявшийся в 2014 году. Участники конкурса строили вычислительные модели (как правило, основанные на использовании глубокого обучения), позволявшие оценивать 12 параметров токсичности у 12 000 лекарственных препаратов и химикатов, встречающихся в окружающей среде. На основании конкурса удалось построить своеобразный ,, обеспечивающий многоступенчатую проверку. На тот момент казалось, что ценность этой работы – в основном академическая и классификационная. Она показала, какие методы глубокого обучения и архитектуры нейронных сетей наиболее удобны для моделирования новых молекул: ,, что таковы метод опорных векторов (SVM), искусственные нейронные сети (ANN), метод k-ближайших соседей (KNN), линейный дискриминантный анализ (LDA), наивный байесовский классификатор (NB) и некоторые другие – от лучшего к худшему. В результате этой работы во второй половине 2010-х появились коммерческие программные пакеты для проектирования новых лекарств. Одной из наиболее современных разработок стала программа ,, использующая вышеупомянутую технологию SMILES и генеративно-состязательные нейронные сети (GAN). , – целое направление разработок в глубоком обучении, особая черта этих нейронных сетей – создание несуществующих, но при этом крайне реалистичных образцов на основе изученного датасета.       ,Летом 2021 года Фабио Урбина и Шон Икинз из компании «Collaborations Pharmaceuticals», штат Северная Каролина, произвели с MegaSyn убийственно простой и тем более шокирующий опыт. Они обратили «функцию полезности», встроенную в этот программный пакет, предоставили программе коммерческий датасет и предложили ей смоделировать вещества, максимально губительные для организма. При этом «по умолчанию» программа проектировала молекулы ,: повышения полезности и повышения биоактивности, и исследователи обратили только одну из этих функций, превратив полезность в токсичность. На такой странный опыт их натолкнула аналогия со знаменитой нейронкой GPT-3, предназначенной для обработки естественного языка. Обратив функцию полезности GPT-3 на противоположную, группа исследователей из Торонто , нейронку разразиться потоком оскорбительных сентенций, прежде всего, расистских, сексистских и бранных., Всего за 6 часов работы нейронная сеть Урбины и Икинза «изобрела» около 40 000 молекул, каждая из которых представляет собой потенциальное химическое оружие. В частности, у нейронки получился газ VX, известный по боевику «Скала»:,Многие из предложенных программой молекул в природе не существуют и пока не получены, но, по всей видимости, также окажутся сильнейшими ядами. Авторы особо подчеркнули, что многие из предложенных нейронкой молекул являются столь экзотическими соединениями, что химики даже не пытались искать токсичных свойств в этой биохимической области. Но, поскольку обращенная функция полезности работает для всех веществ одинаково, в смертоносности этих молекул сомневаться не приходится.,В конце марта 2022 года в журнале «Nature» вышла статья Урбины и Икинза «Dual use of artificial-intelligence-powered drug discovery» («Двойное использование методов открытия новых препаратов с использованием искусственного интеллекта»), обобщающая эти исследования и приходящая к неутешительному выводу, что современные мощности нейронных сетей уже создали условия для возникновения биохимического терроризма. ,Более того, с учетом оптимизации сродства лигандов к белкам и технологии DeepBAR, описанной выше, технология проектирования вредоносных препаратов может найти широкое применение в производстве синтетических наркотиков, которые будут вызывать более острые ощущения и более быстрое привыкание, чем их известные аналоги. Также эта технология могла бы применяться для производства препаратов, подавляющих волю, «сывороток правды», а также «веществ-меток», которые могли бы использоваться для поиска человека по биохимическому анализу крови и при этом очень плохо выводились бы из организма.,Хотелось бы заблуждаться в столь мрачных прогнозах, но даже беглый анализ, представленный в этой статье, позволяет оценить как перспективы, так и опасность применения нейронных сетей в биохимии. Очевидно, что органика – это во многом комбинаторика, и в такой комбинаторике искусственный интеллект сейчас непозволительно превосходит все предохранительные и регулирующие меры, которые мы могли бы принять.    ,Переводчик, PM, автор, просветитель-любитель",Нейронка для нейротоксинов / Хабр
[<200 https://habr.com/ru/post/662181/>],page2,Переводчик-фрилансер,Меняем std::sort для Google / Хабр
[<200 https://habr.com/ru/company/sberbank/blog/662744/>],page2,"Иногда системы контроля версий напоминают групповые чаты: вроде бы все тут собрались по какому-то поводу и пишут о чём-то одном, но что именно пишут ― разобраться порой просто невозможно. Как и в чате, где на одно грамотное и полное сообщение наберётся сотня «гыгы, лол» и «))))))», в Git-коммитах на несколько внятных описаний приходится втрое больше чего-то такого:,c63b59c ЛОГИКА РАБОТЫ File[] filesList; (ВНИМАНИЕ!),3775079 Правки самые последние NEW,71acc53 Правка последняя,Особенно это становится заметно во времена крупных доработок. Когда у разработчика много задач и горящих дедлайнов, есть соблазн плюнуть на написание нормальных комментариев к коммитам (commit messages) и применить золотое антиправило экономии времени «Разберусь потом». Но когда наступает это «потом», комментарии типа , или , не дают ничего, кроме чувства досады на себя в прошлом.,В этой статье мы решили напомнить про правила хорошего тона при написании комментариев к коммитам, чтобы позаботиться о себе и своих коллегах.,Если какая-то фича не работает, самое время проверить, какие изменения выкатили за время её разработки. Всегда хочется чётко понимать, что добавили или убрали, чтобы быстро вернуть к жизни своё творение. Но если вы работаете в большом проекте, то можете даже ни разу не увидеть всех его участников, не говоря уже о том, чтобы спрашивать у них: «А какое изменение ты делал вот тут, Сергей?» ,Вы заходите в лог Git и видите следующие коммиты с комментариями:,a0c03f0 СОГЛАСНО док.1,63d7fa2 >еЛиЗаВеТа<,41f9213 2.03-7.03,82318b8 Что-то ЗАГЛЮЧИЛО-исправлено.,56fa988 Правки от Васи,d80e8bc 1.03, внесли вправки,fe70e42 fg.dfdbd - исправлен,Что за «Док.1»? Что делали со второго по седьмое число? Кто такие Вася и Елизавета? Остаётся закатить глаза, как Роберт Дауни-младший в меме, и идти перекапывать все детальные описания и задачи в таск-трекере. ,Но в репозитории можно увидеть и другое:,027b50f Сделать отправку состояния с помощью JSON,f885497 Добавить сохранение состояния системы в строку ""System"",de542e3 Исправить ошибку с освобождением ресурсов (добавить namesReader.close()),ed3c53f Добавить дополнительный цикл прохода по списку filesList,0047514 Устранить ошибку загрузки из базы данных,b9539fd Изменить логику работы Reader1,Эти комментарии однородные и понятные. Возможно, некоторым из них не хватает детализации, но на уточнение уйдёт буквально пара минут, потому что по описанию уже ясно, где и что искать, а дополнительные пояснения могут находиться в commit body. ,Корректный комментарий к коммиту ― это один из способов эффективной коммуникации в команде, которая зачастую является главным пожирателем времени. Даже две полуторачасовые встречи могут отправить разработчика в интеллектуальный нокаут на полдня. А к ним нередко добавляется ситуативное общение по задачам, общение с новичками и тимлидом, специалистами из других отделов. Если при этом приходится по несколько часов в неделю разбираться с непонятными коммитами, вместо сотрудника скоро останутся тлеющие головешки. Написать хороший комментарий ― это способ сэкономить время и себе, и коллегам, позаботиться о них, помочь не нервничать, не выгорать или хотя бы выгорать медленнее. ,Если это звучит очевидно, то странно, почему в репозиториях до сих пор часто творится неразбериха. Есть 3 очевидных объяснения: ,новички не знают правил;,нет времени писать правильно из-за большой загрузки;,разработчики не хотят соблюдать правила. ,В итоге комментарии становятся не помощью, а никому не нужной обязанностью. Из-за того, что они непонятные, ими не пользуются. А чем меньше ими пользуются, тем ниже мотивация что-то менять. Замкнутый круг. ,Но в среде разработки гласные или негласные правила есть для всего. Придерживаться одной договорённости проще, чем разбираться с последствиями того, что каждый делает по-своему. Будет лучше, если команда договорится о правилах, касающихся следующих аспектов:,содержания комментария ― указывать ли тип, по какой структуре строятся описания в каждой из ситуаций (например, составлять заголовки по логике «,» или «,»), какие слова при этом использовать, в какой форме;,стиля комментария ― как употреблять строчные и прописные буквы, делать ли отступы и переносы, какие знаки препинания можно использовать и т. д.;,метаданных ― как ссылаться на ID задач, указывать ли номер тикета Jira и т. д.,У нас есть свои правила составления описаний для коммитов, однако они не являются чем-то уникальным и секретным. Они коррелируются с тем, о чём рассказывает Крис Бимс в своей , и на , и чего так или иначе придерживаются тысячи разработчиков по всему миру. Расскажем о них подробнее и с примерами. ,Распространённая практика ― добавление ID задачи в Jira или другом трекере задач перед описанием. Это нужно, чтобы быстро перейти к контексту изменения и узнать его детали. Или, наоборот, для того, чтобы быстро найти в Git изменения, относящиеся к конкретной задаче. ,Заголовок ― это очень краткое описание всех изменений, которое первым видит разработчик в инструменте контроля версий. Его оптимальная длина ― до 50 символов. На практике он может быть и длиннее (GitHub оповещает, что объём фразы больше, но разрешает её продолжить). Сокращение заголовка действительно полезно со следующих точек зрения:,именно такой формат проще всего воспринимается при беглом изучении репозитория, позволяет быстро понять суть изменений;,заставляет авторов как можно чётче формулировать свои мысли. В первое время это может раздражать, но через пару недель краткие и ёмкие формулировки начинают будто сами рождаться в мыслях, мы проверяли. ,Заголовок должен быть не только коротким, но и самодостаточным. То есть по возможности содержать фактическую информацию об изменении. Например, можно написать «Создать Python3-правило сборки status.py», и это будет нести исчерпывающий смысл. Но если написать «Создать новое правило сборки», коллеги, скорее всего, просто не станут разбираться и забьют.,Соблазн написать длинный заголовок возникает тогда, когда вы фиксируете сразу много изменений. На этот случай придумали понятие «атомарные коммиты». Это принцип, по которому фиксировать следует каждое частное завершённое изменение отдельно. Это работает, даже когда вы уже ранее закоммитили «пакет» из нескольких доработок. Если в него требуется внести изменения, лучше создать для каждого из них отдельный коммит. Если что-то будет работать не так, не придётся снова откатывать весь «пакет», достаточно будет откатить, например, только последующую корректировку цвета. ,Кроме того, лучше отказаться от принципа фиксации версии только в какое-то определённое время (например, в конце рабочего дня). У каждого коммита должна быть логика: конкретное завершённое изменение или несколько изменений. Также мы обычно фиксируем рефакторинг отдельно от изменений функций или от корректировки ошибок. Например, перемещение класса выполняется одним коммитом, а корректировка ошибки в классе ― другим. Так намного легче искать и понимать изменения. ,Заголовок не только сразу отражает суть изменений в репозитории. Он может использоваться и в других полезных процессах. Например, он может стать темой email при использовании команды git-format-patch. Далее лучше оставлять пустую строку, а ниже размещать более детальное описание, например, указать на причины изменений, если они важны для проекта.,Не каждый коммит требует описания. Если изменения незначительны или не влияют на дальнейшую работу с проектом, то дополнительную информацию можно не вносить.,Например, можно написать просто:,Метод Divider изменить на тип void,А дальше, чтобы получить подробную информацию о том, что именно исправили, любой желающий может воспользоваться командами:, ― отображение изменённого файла в консоли с детализацией изменений;, ― отображение изменений конкретного коммита;, ― отображение всех коммитов от новых к старым с изменениями в файлах.,Если причины изменений критически важны для проекта и могут быть полезны другим разработчикам (например, влиять на дальнейшие действия в проекте), то их следует указать.,Например:,Метод Divider изменить на тип void,Так как класс employee после последних кадровых изменений стал однородным, он не требует разной обработки в зависимости от условий. Поэтому было убрано возвращаемое значение.,Детальное описание удобно выполнять в редакторе, однако его можно оставить и в строке выполнения команды, добавляя к , ключ ,. ,Отделение заголовка от описания позволяет быстрее визуально ориентироваться в информации. ,Вот пример полной записи в журнале:,$ git log,commit facdd14e2a56e5efbba424b0941ac2501da26be8 (HEAD -> master),Author: DanMiller <DanM@exitt.com>,Date: Tue Mar 15 22:30:16 2022 +0300,Метод Divider изменить на тип void,Так как класс employee после последних кадровых изменений стал однородным, он не требует разной обработки в зависимости от условий. Поэтому было убрано возвращаемое значение.,Если вывести только основную информацию о коммите с помощью команды ,, получим:,$ git log --oneline,facdd14 (HEAD -> master) Метод Divider изменить на тип void,И в русском, и в английском языках начало предложения отмечается заглавной буквой, поэтому глаз быстрее и проще распознаёт такую фразу. ,Пример:,f885497 Подключить к базе данных,b9539fd Устранить ошибку загрузки из базы данных,027b50f Сделать отправку состояния с помощью JSON,Написание со строчной буквы может помешать быстрому распознаванию текста. Кроме того, многих это просто раздражает, потому что выглядит неаккуратно. ,Знаки препинания в заголовке обычно не нужны, кроме случаев, когда они помогают раскрывать смысл. Например, заключение слова в скобки может быть необходимо для конкретизации предыдущих фраз в заголовке:,Исправить ошибку с освобождением ресурсов (добавлять namesReader.close()),Точка же не выполняет значимых функций в заголовке, потому что он обычно состоит только из одного предложения. ,Неправильно:,Загрузить начальную конфигурацию.,Правильно:,Загрузить начальную конфигурацию,В целом лишних знаков препинания лучше избегать, чтобы уложиться в минимальное количество символов. ,В английском оригинале это правило звучит как «Используйте глагол в повелительном наклонении», но для русского языка оно не очень подходит. Повелительное наклонение в русском ― это слова типа ,, ,, , и т. д. В английском же повелительное наклонение ― это форма инфинитива без частицы ,. Мы предполагаем, что в английском такую форму рекомендуют использовать просто для краткости, ведь слова в изъявительном наклонении там имеют окончания, которые увеличивают количество символов: , вместо ,, , вместо , и т. д.,Таким образом, ,. Они не сильно короче, чем глаголы в изъявительном наклонении или отглагольные существительные (типа , и пр.), однако выглядят нейтрально, единообразно и прямо называют произведённое действие. ,Заголовок должен быть похож на команду или инструкцию:,Оповестить slave-устройства,Загрузить начальную конфигурацию,Подписаться на топики,Обработать сырую базу значений,Исправить ошибку загрузки из БД,В изъявительном наклонении и с существительными это бы выглядело так:,Настроили оповещение slave-устройств,Загрузка начальной конфигурации,Подписка на топики,Обработка сырой базы значений,Исправили ошибку загрузки из БД,Выглядит разнородно и не очень удобно читается.,Чтобы запомнить это правило и не сбиваться, можно использовать следующий принцип. Заголовок должен логично с точки зрения смысла продолжать фразу «,». Вид глагола при этом может измениться. ,Например:,При применении коммит будет оповещать slave-устройства,  ... будет загружать начальную конфигурацию,  ... будет подписываться на топики,  ... будет обрабатывать сырую базу значений, ... будет исправлять ошибку загрузки из БД,Конечно, если хочется пользоваться всеми возможностями богатого русского языка и писать в прошедшем времени (, и т. д.) или в повелительном наклонении (, и т. д.), то вполне можно это делать. Главное ― договориться об этом с командой и делать единообразно. ,В теле описания можно использовать любые слова и словоформы. ,Тело описания коммита не переносится в GIT автоматически, это выглядит как убегающая далеко за пределы экрана вправо строка, которую неудобно читать. ,Поэтому перенос лучше делать вручную, оставляя на строке 72 символа или менее. Это число неслучайно. Отраслевой стандарт удобочитаемости одной строки ― 80 символов. Однако Git добавляет отступ слева, чтобы описание коммита визуально выделялось, и этот отступ тоже представляет собой символы.,Про форму достаточно, пришло время поговорить про содержание. По описанию другой специалист, который будет работать с репозиторием, должен понимать контекст изменений. В нём может содержаться информация о важных ограничениях в работе. ,В следующем примере разработчик не поленился объяснить, почему были произведены изменения и в чём конкретно они заключались:,commit facdd14e2a56e5efbba424b0941ac2501da26be8 (HEAD -> master),Author: DanMiller <DanM@exitt.com>,Date: Tue Mar 15 22:30:16 2022 +0300,Ввести возможность подписки на систему топиков,Предыдущая версия прошивки не позволяла в полной мере работать с системой топиков из-за возникавших ошибок, поэтому было проделано следующее.,Так как библиотека PubSubClient.h хочет принимать на вход только массив символов (char), был проработан метод autoBuilder() для создания отдельных строк с названиями топиков, чтобы далее, при назначении переменных (#define), вызывать у этих строк функцию c_str() для перевода в массив символов.,Но не все герои носят плащи., Например, если код сложный, то описывать его в commit messages ― это как писать краткое содержание «Войны и мира» (долго, утомительно и бессмысленно). Можно разъяснить сложные моменты в комментариях к коду, а в описании к коммиту изложить, как всё работало до изменений и как стало после. ,Итак, подведём итоги. Корректные и единообразные описания для коммитов важны с двух точек зрения:,их можно удобно и быстро найти и прочитать;,они дают максимально возможное количество информации об изменении с использованием минимального количества знаков.,И поскольку время ― один из самых ценных ресурсов в современном мире, его экономия для себя и своих коллег ― это отличный способ проявить заботу. ,Для того чтобы описания были корректными, мы рекомендуем соблюдать восемь правил:,добавлять ID задачи;,писать короткие заголовки ― до 50 символов;,делать отступ между заголовком и описанием;,писать заголовок с заглавной буквы;,не ставить точку в конце заголовка описания;,использовать в заголовке глагол в форме инфинитива;,ограничивать длину строки в теле описания 72 символами;,в теле описания отвечать на вопросы: «Что сделали?» и «Почему сделали?»,Что вы думаете об этих правилах и как сами пишете описания?,SMM,","8 правил, которые пригодятся при описании Git-коммитов / Хабр"
[<200 https://habr.com/ru/company/swordfish_security/blog/661345/>],page2,"Привет, Хабр! ,Меня зовут Юрий Шабалин, и, как я пишу в начале каждой своей статьи, мы разрабатываем платформу анализа защищенности мобильных приложений iOS и Android. ,В этой статье мне бы хотелось затронуть тему безопасной конфигурации сетевого взаимодействия, а также немного расширить , для механизма защиты канала связи в iOS. А именно, я расскажу про App Transport Security: для чего он нужен, использовать ли его или отключать в приложениях, в чем его польза. ,На эту тему существуют статьи на англоязычных ресурсах (здесь можно многие из них найти в разделе “,“), достаточно подробно эта тема раскрыта в документации Apple, но на русском я статей практически не встречал. Но даже если они есть, я с удовольствием добавлю свой материал с практическими примерами в эту небольшую копилку.  ,Apple от версии к версии iOS продолжает радовать нас различными нововведениями в части безопасности. В последнее время это больше связано с приватностью пользователей, их данными, местоположением и т.д. А для нас особый интерес представляет обновление механизма конфигурации безопасного сетевого соединения - App Transport Security - в iOS 9.0 в 2015 году. ,Это событие можно рассматривать как попытку Apple сделать мобильные приложения более защищенными, точнее, дать разработчикам инструмент для самостоятельного управления настройками сетевого соединения, и не через код приложения, а посредством конфигурации специального домена в основном файле ,. Ключевыми задачами данного механизма являются отключение для приложения возможности общаться по незащищенному протоколу HTTP, а также обязательная поддержка последних версий TLS на сервере для обеспечения Perfect Forward Secrecy (про это можно подробно почитать в нашей ,). Изначально компания Apple собиралась сделать применение App Transport Security обязательным для всех приложений, представленных в App Store, начиная с января 2017 года. Однако, за несколько недель до этой даты ,. И, хотя было анонсировано назначение новой даты, до сих пор использование ATS является необязательным. ,Нечто подобное предложили в дальнейшем и в Android 7 в 2016 году, в виде файла настройки Network Security Config. ,Что интересно, различные рекламные сервисы, например, Google AdMob, для своей корректной работы рекомендуют просто ,в вашем приложении. Классный совет, спасибо, Google! Мы всегда знали, что ты - за безопасность!,Не всякий сервер подойдет для подключения с использованием ATS. Если ваш не удовлетворяет необходимым требованиям, то соединение завершится с ошибкой,Вот каким должен быть сервер, чтобы применять ATS:,Все шифронаборы должны использовать алгоритмы, поддерживающие Perfect Forward Secrecy;,Наличие TLS версии не ниже 1.2;,Для всех сертификатов необходимо использовать, как минимум, отпечаток SHA256 с ключом RSA (2048 или выше) или с ключом 256 бит или более.,Для успешного подключения к серверу с использованием ATS на клиенте подойдут следующие шифронаборы:,Но даже если ваш сервер не удовлетворяет заданным требованиям безопасности для использования ATS, конфигурацию можно настроить. Хотя можно и задуматься о доработке серверной части. ,Для того, чтобы определить, какие настройки необходимо проделать с ATS, чтобы он корректно работал, можно использовать команду , с параметром ,. Результатом вывода команды будут успешные и неуспешные проверки по всем пунктам ATS:,Если все проверки пройдены успешно, соединение может быть беспрепятственно установлено из приложения. А в случае каких-либо ошибок можно настроить соответствующее исключение в файле конфигурации. ,К примеру, если не отработала проверка на ,:,В этом примере видно, что успешно установить соединение будет возможно, только если отключить ,. Поэтому в , файле для домена , необходимо указать ,.,Для того, чтобы проверить, какие шифронаборы используются и включены на вашем сервере, можно запустить , со специальными параметрами ,Будет создан отчет, аналогичный приведенному ниже, в котором показано, какие версии TLS поддерживаются и какие шифронаборы можно применять.,Кроме того, существуют  сайты, например, ,, позволяющие проверить, совместимы ли общедоступные веб-сайты с ATS.,Секция по настройке App Transport Security в , называется , и имеет следующую структуру:,Далее мы разберем детально каждый из этих параметров: за что отвечает, какое значение имеет по умолчанию. Также поговорим о том, что может произойти, если эти параметры будут настроены небезопасным образом, и посмотрим на примерах, как автоматически это определять.,Ключ , определяет состояние ATS в целом, видит включено или выключено оно для приложения. По умолчанию, для ключа , установлено значение ,, то есть App Transport Security включен полностью. Установка ключа в значение ,приведет к полному отключению всех проверок. Это означает, что система не будет запрещать приложению взаимодействовать с любыми доменами по протоколу HTTP, а также не будет применять никаких дополнительных проверок к установке сетевого соединения. Крайне не рекомендуется отключать ATS на уровне всего приложения. Лучше потратить немного времени и разобраться, что не работает и как это можно исправить.,Если вы все-таки решите отключить ATS, то рекомендую проконтролировать несколько моментов, которые автоматически проверяются при его использовании:,Шифры для сетевого взаимодействия приложения (и их надежность);,Протоколы, применяемые для отправки и получения данных (и их безопасность);,Наличие в приложении уязвимостей для перехода на более раннюю версию протокола шифрования;,Осуществление проверок приложения сертификатами, используемыми для TLS-подключений.,Это исключение относится к мультимедийному контенту, защищенному системой управления цифровыми правами (DRM) или шифрованием. По умолчанию, для ключа , установлено значение ,. Если для него установлено значение ,, ATS отключается для контента, отправляемого с использованием ,. Обычно это происходит с приложениями, включающими в себя возможность работы с видео/аудио контентом. ,Если по какой-то причине необходимо отключить ATS, рекомендуется дополнительно обратить внимание на то, чтобы мультимедийные данные, отправляемые приложением, не содержали конфиденциальных данных и были защищены с помощью DRM или шифрования. ,По опыту: я не очень часто встречал подобные исключения и подобный контент в приложениях. Уверен, что они есть, но в моей практике они достаточно редки.,Есть один интересный нюанс: если WebView (а именно, компоненты , и ,) используется для отображения произвольных адресов, то невозможно составить весь их список и понять, правильно ли они настроены для соединения при помощи ATS. Apple предоставила два возможных решения данной проблемы.,Первое из них - это использование ключа ,. Он определяет, возможно ли соединение по небезопасным протоколам из компонентов WebView. По умолчанию, для этого ключа установлено значение ,. Если установить значение ,, ATS будет отключен для WebView. Этот ключ появился только в десятой версии iOS. Есть несколько нюансов, относящихся к старым версиям iOS, но их мы рассматривать не будем, поскольку они уже неактуальны. ,Второй, и более адекватный вариант, - использование ,, который был специально разработан для этих целей. Обратимся к документации Apple:,“Используйте класс ,, если ваше приложение позволяет пользователям открывать произвольные Web-сайты. Используйте класс , для контента, который находится под вашим управлением”.,Применяя ,, нужно помнить о некоторых специфических вещах:,ATS в данном компоненте отключен. Это позволяет загружать и отображать любой веб-контент с любых источников независимо от конфигурации HTTPS;,Cookies и данные Web-сайтов передаются Safari. Это позволяет, например, оставаться аутентифицированным на различных ресурсах, в которых пользователь логинился из браузера;,Способов контроля и управления по сравнению с , существенно меньше.,Из этих двух вариантов, при возможности, лучше использовать компонент , для отображения произвольных веб-сайтов вместо отключения ATS для всех WebView.,Ключ , определяет работу ATS в локальной сети.,По умолчанию, для ,установлено значение ,.  Обычно это исключение используют приложения, подключающиеся к локальным устройствам для работы Интернета вещей (IoT). При отключении ATS убедитесь, что во время взаимодействия в локальной сети не передаются конфиденциальные данные, а также используется безопасное TLS-соединение.,При применении ключа , появляется возможность настраивать исключения ATS для отдельных доменов. При этом не стоит забывать, что подразделы ATS внутри ,заменяют другие первичные ключи. Например, если приложение загружает мультимедиа из определенного домена, для которого используются и исключение , на верхнем уровне, и конфигурация ,, то параметры , имеют приоритет. Другими словами, они заменяют значение ключа , верхнего уровня. Фактически, для конкретного домена силу имеют только настройки, указанные в исключениях для него. В разделе с примерами мы рассмотрим это чуть подробнее.,Вторая особенность заключается в том, что если домен в исключениях указан без какой-либо конфигурации, то он получит полную защиту ATS, даже если для параметра ,установлено значение ,. Таким образом, разработчик может отключить ATS глобально, но включить его для определенных доменов, указав их в ключе ,. Это еще один способ позволить приложению осуществлять загрузку данных с произвольных серверов без их проверки на совместимость с ATS (при включенном ATS для выбранных доменов).,Но, на самом деле, это достаточно плохая практика и, возможно, стоит еще раз посмотреть на архитектуру вашего приложения. ,Если вы указываете исключения для доменов, ATS игнорирует любые ключи глобальной конфигурации, включая NSAllowsArbitraryLoads, для этого домена. Это работает, даже если вы оставите словарь для домена пустым и полностью доверитесь значениям его ключей по умолчанию.,Данный ключ определяет, будет ли применяться политика ATS для поддоменов.,По умолчанию, для ключа , установлено значение ,. Если установлено значение ,, любая конфигурация ATS, включенная для определенного домена, будет использоваться для всех поддоменов. И, если установлен домен, но не настроено никаких дополнительных ключей, кроме ,, этот домен и его поддомены будут использовать ATS. ,Ключ ,определяет, возможна ли передача незащищенного трафика HTTP на указанный домен.,По умолчанию, для этого ключа установлено значение ,. Если установлено значение ,, приложению будет разрешено отправлять HTTP-трафик на этот домен. ,Этот ключ позволяет снизить минимально допустимую версию TLS. По умолчанию, к таким версиям принадлежат TLS 1.2 и выше. ,Данный ключ определяет использование свойства Forward Secrecy для конкретного домена.,По умолчанию, для этого ключа установлено значение ,. Если выставлено значение ,, свойство Forward Secrecy будет отключено для этого домена. ,Данный ключ определяет использование свойства Certificate Transparency (прозрачность сертификатов) для конкретного домена.,По умолчанию, для этого ключа установлено значение ,. Если для ключа установлено значение ,, для сертификата домена потребуется метка времени Certificate Transparency. , - это проект Google, ориентированный на повышение безопасности системы выпуска сертификатов SSL. Если ваша организация или рассматриваемый домен поддерживает Certificate Transparency, рекомендуется включить данную опцию. Это помогает выявлять мошеннические центры сертификации и предотвращать атаки типа «человек посередине», уведомляя владельца, если его сертификат был скомпрометирован. Когда этот ключ включен, проверки сертификатов, связанные с Certificate Transparency, выполняются до установления соединения.,Начиная с iOS 14, в AppTransport Security появился нативный механизм реализации прикрепления сертификатов (certificate pinning). В документации о нем сказано не много, основным источником информации является ,. Резюмируем ее содержание:,В Info.plist можно указать набор сертификатов, которые App Transport Security (ATS) ожидает при подключении к указанным доменам,Закрепленный открытый ключ должен присутствовать либо в промежуточном, либо в корневом сертификате,Приложение не сможет подключиться к указанному в настройках домену, если проверка цепочки сертификатов окажется неуспешной,Можно связать несколько открытых ключей с одним доменным именем.,Для начала поговорим о том, как нам получить отпечаток, который нужно указать в настройках. Чтобы определить всю цепочку сертификатов (то, что будем закреплять), можно воспользоваться OpenSSL:,Из вывода команды можно определить, что для , есть один конечный сертификат, сертификат промежуточного центра сертификации, а затем корневой сертификат.,Для получения отпечатка SPKI, можно сохранить любой сертификат в виде файла формата PEM, а затем передать его на вход в следующий скрипт (пример для MacOS):,Или же воспользоваться командой из документации:,Результирующий отпечаток конечного сертификата в приведенном выше примере — ,, а центр сертификации — ,.,Теперь мы можем добавить эти значения в Info.plist:,В приведенном выше примере мы указываем, что отпечаток открытого ключа связан с доменом , и его поддоменами, например ,. Но вот поддомены третьего уровня и выше в эту проверку уже не попадают (например ,). Также будем проверять центр сертификации, что указано в ключе  , и сертификат конечного сервера, за который отвечает ключ ,.,Можно сразу же указать несколько отпечатков, что может быть полезно при ротации сертификатов на сервере:,Но как показывает практика, это работает не всегда. Такой способ хорош для ,, но не подходит для API поверх ,. , по-прежнему будет подключаться и загружать контент из домена, если открытый ключ SSL отличается от указанного в , также не учитывает настройки в ,. Такое поведение неудивительно, учитывая, что SFSafariViewController выполняется в отдельном ,., пока неутешительный, поскольку не несет в себе никакой конкретики. Непонятно, будут ли когда-то настройки Certificate Pinning из AppTransport Security работать для всех API. Может быть, однажды это случится, ну а сейчас просто надо учитывать эту особенность при разработке.,Если говорить про идеальную конфигурацию, то это, конечно, включение ATS в полном объеме на уровне всего приложения и без исключений для доменов:,К сожалению, такое встречается очень редко. Сегодняшние мобильные приложения зачастую используют большое количество сторонних сервисов, которые они не контролируют, и не могут гарантировать обеспечения должного уровня безопасности, например, использование корректной версии TLS.,Полностью отключить ATS можно, указав флаг,. Такая конфигурация рекомендуется только для отладки. ,К сожалению, во многих приложениях мы до сих пор встречаем полностью отключенный ATS:,С чем это связано, до конца не ясно, но я надеюсь, что эта статья натолкнет на мысли о более детальной конфигурации приложения.,Как было сказано выше, возможны ситуации, когда приложение взаимодействует с серверами, не отвечающими требованиям ATS. В этом случае нужно сообщить операционной системе, какие именно это домены, и указать их в , вашего приложения (и отметить, какие именно требования не выполняются).,Здесь стоить помнить про одну важную деталь: конфигурация исключений может быть очень интересна злоумышленникам, особенно если вы оставляете в продуктивной сборке адреса тестовых стендов. ,Как правило, такие стенды, если они имеют доступ в интернет, намного слабее “охраняются“ различными средствами защиты, мониторингом и прочими разработками. А значит, их интересно  исследовать на предмет наличия уязвимостей. А дальше уже можно попробовать зайти в сеть и развернуться по-настоящему. Как я говорил в других статьях, одна уязвимость или даже недостаток в мобильном приложении не являются такой уж огромной проблемой (конечно, если это не какая-то инъекция или RCE). Однако, наличие нескольких слабостей помогает выстроить в вектор атаки, который сработает и принесет реальный ущерб приложению или пользователям.,Не очень правильный, но все-таки имеющий право на жизнь способ - отключить ATS для всего, кроме ваших серверов. Конечно, не очень хорошо так делать, но это лучше, чем отключать ATS вообще. Вот как может выглядеть , при такой конфигурации:,В этом случае приложение сможет осуществлять соединения со всеми серверами вне зависимости от корректности настройки HTTPS (да и просто по HTTP), но для выделенного в исключения домена ,подключения можно будет осуществлять только по HTTPS. Также для него будут применяться все остальные требования ATS.,При такой конфигурации подключение к домену ,и всех его поддоменов не будет требовать настройки Perfect Forward Secrecy. Она может применяться, например, если на вашем сервере не настроены правильные шифронаборы, позволяющие использовать это крайне полезное свойство.,В следующем , мы определим три исключения и затем разберем их более детально:,Первое исключение, которое мы определили, сообщает ATS, что связь с этим поддоменом отменяет требование обязательного использования HTTPS. Оно применяется только к конкретному адресу, указанному в исключении, и не затрагивает поддомены. Не стоит забывать, что ключ , относится не только к использованию HTTPS, а и к ATS в целом. Таким образом, для этого домена отменяются все требования App Transport Security.,Возможна ситуация, в которой приложение обращается к серверу, не использующему необходимую версию TLS (1.2 или выше). В этом случае можно определить исключение, указывающее минимальную версию TLS, которая может использоваться. Это будет лучше с точки зрения безопасности, чем полное отключение App Transport Security для этого домена.,Ключ , сообщает App Transport Security, что исключение применяется к каждому поддомену указанного адреса. Кроме того, определяется, что домен может использовать шифры, которые не поддерживают Forward Secrecy (,).,ATS - это очень хороший инструмент, позволяющий намного лучше и проще контролировать происходящее в вашем приложении. Видно, к каким серверам оно обращается, как они настроены и т.д. Кроме того, эта настройка помогает, в какой-то мере, контролировать состояние серверных частей приложения и поддерживать их безопасную конфигурацию. Да, механизм ATS - не только про клиента, он в какой-то степени заставляет backend придерживаться лучших практик безопасности. Так что перед тем, как просто отключить ATS в приложении, задумайтесь: “Может, пришло время правильно сконфигурировать серверную часть?” Также проанализируйте, какие ресурсы, кроме собственных, вы используете, и почему для них нужно отключать потенциальную защиту?,Конечно, хотелось бы видеть в настройке App Transport Security и другие параметры, например, связанные с SSL Pinning (по аналогии с тем, как это сделано в Android). Это позволило бы не искать свои пути для каждого фреймворка, а задавать это на уровне системы. Но, к сожалению, думаю, что этого мы уже не дождемся.,Надеюсь, что эта статья поможет всем интересующимся понять нюансы настройки App Transport Security, а возможно и заставит правильно его сконфигурировать для своего приложения, вместо полного отключения.,   ,  ,  ,  ,  , ,  , , , , , , ,Архитектор по информационной безопасности",И снова про App Transport Security: что это и зачем / Хабр
[<200 https://habr.com/ru/post/662692/>],page2,"В предыдущей статье , впервые и крайне кратко представлен описанный в данной статье подход. Пришло время детально раскрыть нюансы и глубину потенциала нового подхода, когда основным протоколом для взаимодействия браузера и мобильных приложений с сервисами Spring Cloud выступает WebSocket.,Spring Cloud Gateway официально служит следующим целям: слоем безопасности, маршрутизатором, балансировщиком, провайдером протоколов сжатия. Gateway ничего не знает о передаваемых данных и тем более о бизнес-логике – это инфраструктурный сервис.,Связь Gateway с WebSocket обуславливает здравый смысл. Если перенести логику WebSocket  в Gateway, то при высоких нагрузках потребуется ненамного увеличить количество подов с одной стороны, а с другой если через WebSocket работают не только браузеры, но и мобильные приложения – то такой подход становится естественным.,В статье описываются преимущества данного подхода, детально перечисляются нюансы реализации и определяются общие перспективы дальнейшего развития. Но основная идея сводится к уменьшению стоимости разработки за счёт переиспользования базовых технологий для всего необходимого функционала.,В эпоху рассвета мобильных приложений на Android, в то время, когда в 2009 году Samsung объявил об отказе от Symbian и переходе на Android (iOS ещё не было) – WebSocket в том же году был ещё в виде черновика, т.е. исторически мобильные приложения не застали эту технологию и развитие ушло своим чередом.,Кроме того, существовала проблема при переключении телефона с одной соты на другую – также менялся и IP-адрес телефона, что прерывало все установленные соединения. Данный фактор был не в пользу WebSocket, который в исходной версии не умел переподключаться при обрыве связи. Сейчас, качество связи стала очень стабильной, а IP-адреса внутри сети мобильного оператора привязаны к телефону. Можно сказать появились тепличные условия для восхождения WebSocket и почему бы и нет.,В представленном проекте ,, интеграция WebSocket не повлияла на работу и исходный код существующих сервисов, т.к. конвейер сообщений WebSocket в Restful прозрачно конвертирует запросы и ответы.,Преимущества использования конвейера WebSocket в Restful следующие:,Классический микросервисный подход Spring Cloud к организации обработки потока данных на стороне бэкенда как от браузера так и от мобильных приложений по WebSocket, когда сервисам не интересно откуда приходят http-запросы;,Единое понятие сессии: отключение всех соединений WebSocket пользователя однозначно сообщит о закрытии сессии как в браузере, так и в мобильном приложении (такое знание для многих бизнес-процессов критично);,Открытые соединения WebSocket точно определяют количество пользователей онлайн, в то время как в случае http-запросов онлайн считается по количеству запросов за последние полчаса;,Более не требуется тратить значительные ресурсы на организацию Push-уведомлений – полученные через WebSocket уведомлений ничем не отличаются визуально, при условии когда приложение запущено (что в подавляющем большинстве случаев приемлемо);,При высоких нагрузках WebSocket заметно быстрее HTTP и значительно меньше потребляет трафика, при этом, поддерживает , в обе стороны;,Из коробки , (политика безопасности на основе происхождения);,Прямым преимуществом использования WebSocket перед http-запросами в возможности обратной связи в реальном времени, что позволяет строить современные высококонкурентные реактивные интерфейсы в мобильных приложениях.,Если принять во внимание факт   увеличения расхода батареи из-за постоянно открытого соединения WebSocket, то согласно GSM Arena с 2010 года плотность аккумуляторов к 2020 году выросла в 3 раза и при том же форм-факторе ёмкость батареи достигла 5000 мАч.,А если ещё учесть время на полную зарядку современных аккумуляторов от сети в 15 минут, то при таких темпах развития данный факт можно смело отнести к незначительным.,Конечно, Gateway продолжит маршрутизацию и балансировку http-запросов, т.к. останутся: авторизация пользователя, запросы выдающие большие объёмы данных, выгрузка файлов в браузер, а также интеграция внешних систем.,Рассматриваемый в статье проект , позволяет снизить стоимость разработки и владения за счёт использования классического подхода http-запросов при работе с браузером и мобильными приложениями по протоколу WebSocket, а также эффективной утилизации сессий в момент окончания жизни jwt-токена. Представленный исходный код несмотря на небольшой размер и простоту реализации – эффективно выполняет все описанные в статье возможности.,В 2013 году один из разработчиков проекта Socket.io , закомитил ,, которая также активно дорабатывается и в настоящее время. А спустя 4 года появился , также с полной поддержкой WebSocket.,В 2014 году вышла в релиз спецификация JSR 356, поддержка которой привела к включению в Java Development Kit (JDK) пакета ,. В дальнейшем, непосредственно в Kotlin Standard Library была внедрена обвёртка вокруг DOM API с базовым классом WebSocket – который также можно использовать в Android приложениях.,Помимо нативных библиотек от команды Socket.io, существует более десятка сторонних с полной имплементацией протокола WebSocket по спецификации RFC 6455 и большинство из них активно поддерживаются довольно крупными сообществами.,Наиболее распространённая практика использования WebSocket в среде iOS – это , от Facebook, а в среде Android – , от opensource разработчика Nathan Rajlich, создавший проект в 2010 году (скорее всего для нужд одного из клиентов фондовой биржи NASDAQ).,WebSocket профессионально присутствует в мобильных приложениях более 10 лет, т.к. на глобальном уровне требование к доставке данных в реальном режиме времени постоянно расширяется с каждым новым типом данных из года в год.,Браузер или мобильное приложение отправляет и принимает запросы по WebSocket в обвёртке:, Атрибуты образуют http-запрос к сервисам:  ,type – тип ,, ,, ,, ,, ,, ,, , (по умолчанию ,baseUrl – имя сервиса, например: ,uri – метод контроллера и query-запрос, например: findAllPaged?sort=id:desc,body – json запроса при типе запроса ,, , или , 	 	,при формировании ответа , заменяется ответом с сервиса: ,, а , и , служат идентификаторами запроса в обработчике WebSocket в браузере или в мобильном приложении.,Функция преобразования запросов WebSocket в Restful и обратно:,Рассмотрим публикацию точки входа для реактивного WebSocket для конвертации запросов из WebSocket в HTTP к сервисам и обратно:,Кэш , на базе библиотеки Caffeine, имеет ограничение по времени и ограничение по размеру количества открытых соединений WebSocket, а при завершении сессии по таймауту посылает в Kafka событие:,События Kafka отправляются через сервис EventDriverPublisher, где представлены методы по каждому типу события – это связано с необходимостью типизации модели для сериализации, т.к. для сжатия используется библиотека Apache Avro. Соответственно, все модели Kafka предварительно генерируются плагином avro-maven-plugin., Описание модели WebSocketEvent:,Реализация методов класса EventDrivenPublisher:,Конфигурация Kafka в application.yml:,Рассмотрим части кода точки входа для WebSocket :,то видно, что соединение WebSocket через объект it = FluxSink сохраняется в кэше clients для дальнейшей отправки сообщений пользователю в браузер или в мобильное приложение в структуре MessageWrapper по его идентификатору, который представлен как name.,конструкция , позволяет перехватить момент закрытия соединения WebSocket, корректно завершить сессию и отправить событие Kafka.,В Gateway включена библиотека , и чтобы подключится к WebSocket необходимо передать в заголовке jwt-токен, который для производительности валидируется только по времени и по подписи публичным ключом.,В Gateway также включена библиотека ,, которая инициализируется в Spring как CacheManager и запускает сервер  Hazelcast как embedded вместе с сервисом. Уникальной особенностью данной библиотеки является возможность задания максимального размера кэша, что отсутствует в исходном Hazelcast.,Параметры кэша прописываются в application.yml:,Хеш токена кэшируется в кластере Hazelcast на уровне подов одного сервиса на время жизни токена и при повторном обращении результат валидации возвращается из кэша. Токен отзывается по завершении сессии пользователя при котором инициируется событие Spring: , и в запись кэша токена вносится метка о деактивации токена.,Для асинхронной отправки сообщений в WebSocket через событие Kafka добавлен роутер:,который ожидает модель EventWrapper:  ,и вызывает метод publish:,после чего, в произвольный топик Kafka публикует сообщение из ,.,Если мы хотим отправить сообщение в WebSocket определённому пользователю, тогда в , указывается значение ,, а в , описывается модель MessageWrapper:,В классе KafkaConsumerConfiguration создана подписка на топик ,, которая перенаправляет события в WebSocket:,В качестве итога обзора небольшого, но эффективного кода можно также показать то небольшое количество подключаемых зависимостей в файле сборки pom.xml:,Простая идея интеграции в действующий Spring Cloud Gateway конвейера WebSocket в Restful уже существующих микросервисов и обратно – открывают множество возможностей и перспектив. В частности, отказа от часто дорогой инфраструктуры вокруг Push-уведомлений. И при этом, Push-уведомления имеют ряд недостатков, такие как произвольные задержки транспорта, внеочерёдность уведомлений, переполнение пула очереди.,Кроме того, существующий фронт в браузере и в мобильных приложениях необязательно сразу переписывать под использование конвейера WebSocket, ведь Gateway продолжает свою работу по маршрутизации и балансировке.,Сначала, на фронт можно добавить асинхронную фабрику обработки входящих сообщений для реактивной адаптации интерфейса, а потом достаточно подменить используемую сетевую библиотеку на свою с тем же API, чтобы на заднем фоне упаковать запросы в обвёртку и отправить запрос через WebSocket.,WebSocket на сегодняшний день самый популярный протокол реального времени, ставшим стандартом де-факто в мобильных приложениях, таких как финансовые инструменты, социальные сети, навигация по местоположению и конечно компьютерные игры.,Архитектура WebSocket соответствует модели управляемых событий Event-Driven, а код оптимизирован для минимизации overhead по трафику и latency при передаче данных по сети. В наступившее время широкополосных каналов Интернет – WebSocket позволяет в полной мере реализовать реактивные интерфейсы, «оживив» таким образом мобильное приложение в руках пользователя.,Системный архитектор",Reactive Spring Cloud Gateway: конвейер WebSocket в Restful и обратно / Хабр
[<200 https://habr.com/ru/post/662718/>],page2,"Подборка мероприятий на неделю,Присоединяйтесь, если вы:,
ищете новые каналы продаж;,
только начинаете осваивать российские рекламные платформы, сервисы и маркетплейсы.,Кто участвует,
VK, Яндекс.Директ, Яндекс.Маркет, Ozon, PromoPult т,Retail Rocket организует онлайн-конференцию Retention Day#3 🚀 Лидеры рынка расскажут, как сейчас привлекать новую аудиторию и работать с главным активом компании в любой кризис – текущей клиентской базой.,✅ iProspect даст прогнозы, как изменится e-com в ближайшее время, и как подстроиться под эти перемены,
✅ Hoff и «Подружка» поделятся кейсами, как увеличить выручку с помощью персонализации на сайте, в мобильном приложении и рассылках,
✅ Aviasales расскажет, как запускать эффективные рекламные проекты даже в непростые времена,
✅ VK и «Яндекс.Маркет» разберут, какие рекламные инструменты стоит сейчас использовать для продвижения,
✅ Setters объяснит, как продвигаться, размещая рекламу в сообществах,Кого мы ждем на нашем мероприятии:,
•специалистов корпоративного отдела,
•hr-специалистов,
•специалистов АХО,
•специалистов компании по внутренним мероприятиям,
•специалистов отдела маркетинг,На мероприятии вы узнаете:,
•о ситуации с винами на рынке,
•на что стоит обратить внимание при выборе вин,
•винные лайфхаки,
•о сочетаемости и несочетаемости продуктов с вином,Почему ВАМ стоит прийти на мероприятие?,
•вы узнаете о ситуации на рынке event-мероприятий из первых уст,
•у вас появится прекрасная возможность рассказать о себе,
•новые знакомства,
•наращивание социального капитала,
•вкусная кухня, отличное вино и возможность выиграть приз,Ну и, конечно, мы надеемся, что в нашем лице вы найдёте надёжного партнёра, которому сможете доверить организацию вашего корпоративного мероприятия.,Пользователь",Digital-мероприятия в Москве c 25 апреля по 1 мая / Хабр
[<200 https://habr.com/ru/company/pt/blog/662768/>],page2,"Коллекционеры уже давно не хранят произведения искусства в сейфах — галереи и музеи по уровню безопасности не уступают самым надежным хранилищам. Но можно ли украсть картину, не выходя из дома? ,На , в мае пройдет обновленный The Standoff Digital Art: азартные исследователи снова попытаются завладеть крипто-артом настоящих художников прямо в метавселенной, а гости форума побывают в Лондоне, не покидая Москвы.,Прошлый год можно смело назвать годом NFT. Объем торгов на этом рынке , $41 млрд, вплотную приблизившись к классическому арт-рынку. Токены позволяют каждому владеть уникальными предметами. Когда у художников, особенно во время карантина, появились новые возможности по продаже работ, на сцену вышли кибермошенники: в сфере NTF нередки фишинг и эксплуатация уязвимостей в смарт-контрактах. Эксперты не исключают появления новых методов мошенничества на этом рынке.,На The Standoff в ноябре белым хакерам уже , произведения шести российских диджитал-художников. Свои работы предоставили ,, ,, ,, ,, , и ,. Чтобы завладеть картиной, исследователи безопасности находили уязвимости в смарт-контрактах. Для этого они анализировали исходный код, опубликованный в тестовой сети блокчейна Ethereum. Каждый NFT взламывали только один раз. Пять из них поддались Алексею Быхуну уже в первые часы конкурса, а с последней справился Алексей Егоров., ,, — отмечает Арсений Реутов, руководитель отдела исследований безопасности приложений Positive Technologies.,Картины российских художников появятся в виртуальных арт-галереях , за неделю до форума. С помощью приложения цифровую выставку можно будет посетить из любой точки мира.,, — говорит Илья Коргузалов, основатель метавселенной Arcona.,Блокчейн помнит все. Именно это могут использовать хакеры. Участникам конкурса предстоит провести свое расследование и найти информацию, которая позволит им завладеть цифровыми картинами. ,На форуме также пройдет уникальная акция: прямо из Москвы в Лондоне будет дистанционно запущен тематический AR-проект! На глазах зрителей в британской столице развернется интерактивная инсталляция, сгенерированная в московской студии.,Соорганизатором форума PHDays 11 и кибербитвы The Standoff выступает ,. Бизнес-партнерами форума стали разработчик решений ИБ ,национальный провайдер сервисов и технологий ИБ «,» и дистрибьютор ПО для любого бизнеса ,. Технологический партнер — «,». Партнеры PHDays 2022 — компании ,, ,, «,», ,, «,», ,, «,», «,», «,», Liberum Veritas, ,, ,.,Хотите увидеть все сами? , на PHDays 2022!,Пользователь",PHDays 2022: киберарт под угрозой. Снова / Хабр
[<200 https://habr.com/ru/company/ruvds/blog/661429/>],page2,Пользователь,KC868-AG: IoT шайба / Хабр
